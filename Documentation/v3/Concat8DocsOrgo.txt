===== TOC (8 files) =====
0001  1-orgo-database-schema-reference.md
0002  2-orgo-documentation-index.md
0003  3-orgo-full-stack-technical-spec.md
0004  4-orgo-functional-code-name-inventory.md
0005  5-orgo-Core-Services-Specification.md
0006  6-orgo-insights-module-config-parameters.md
0007  7-orgo-organization-profiles-and-cyclic-overview.md
0008  8-orgo-cyclic-overview-labels-and-flow-rules.md
===== END TOC =====


===== BEGIN 1-orgo-database-schema-reference.md (#0001) =====
﻿Preface
1.1 Scope
1.2 Technology & naming assumptions
1.3 Multi‑tenancy conventions
1.4 Default audit columns
1.5 Enum implementation

Module 1 – Core Platform & Multi‑Tenancy
2.1 Organization (organizations)
2.2 Organization Profile (organization_profiles)

Module 2 – Identity & Access Control
3.1 User Accounts & Person Profiles (user_accounts, person_profiles)
3.2 Roles, Permissions & User Role Assignments (roles, permissions, role_permissions, user_role_assignments)
3.3 Sessions & API Tokens (login_sessions, api_tokens)

Module 3 – Communication & Email
4.1 Email Account Configuration (email_account_configs)
4.2 Role Inboxes (role_inboxes)
4.3 Email Threads & Messages (email_threads, email_messages)
4.4 Email Attachments (email_attachments)
4.5 Email Ingestion & Processing Events (email_ingestion_batches, email_processing_events)

Module 4 – Task & Workflow Engine
5.1 Tasks, Assignments, Events & Comments (tasks, task_assignments, task_events, task_comments)
5.2 Routing Rules (routing_rules)
5.3 Workflow Definitions & Instances (workflow_definitions, workflow_instances, workflow_transition_events)
5.4 Escalation Policies, Instances & Events (escalation_policies, escalation_instances, escalation_events)

Module 5 – Configuration, Parameters & Feature Flags
6.1 Parameter Overrides (parameter_overrides)
6.2 Feature Flags (feature_flags)

Module 6 – Labeling & Classification
7.1 Label Definitions (label_definitions)
7.2 Entity Labels (entity_labels)

Module 7 – Notifications
8.1 Notification Templates (notification_templates)
8.2 Notifications (notifications)

Module 8 – Logging, Audit & Observability
9.1 Activity Logs (activity_logs)
9.2 Security Events (security_events)
9.3 System Metric Snapshots (system_metric_snapshots)

Module 9 – Cases (Generic)
10.1 Cases (cases)

Module 10 – Domain: Operations & Maintenance
11.1 Maintenance Assets (maintenance_assets)
11.2 Maintenance Task Links (maintenance_task_links)
11.3 Maintenance Calendar Slots (maintenance_calendar_slots)

Module 11 – Domain: HR & Wellbeing
12.1 HR Cases & Participants (hr_cases, hr_case_participants)
12.2 HR Case Task Links (hr_case_task_links)
12.3 Wellbeing Check‑Ins (wellbeing_checkins)

Module 12 – Domain: Education & Groups
13.1 Learning Groups & Memberships (learning_groups, learning_group_memberships)
13.2 Education Task Links (education_task_links)

Module 13 – Offline & Sync
14.1 Offline Nodes & Sync Sessions (offline_nodes, sync_sessions)
14.2 Sync Conflicts (sync_conflicts)
14.3 Email Archive Imports & Message Mappings (email_archive_import_batches, imported_message_mappings)

Module 14 – Analytics / Insights Star‑Schema (insights.*)
15.1 Date & Organization Dimensions (insights.dim_dates, insights.dim_organizations)
15.2 Task, Case, Person & Group Dimensions (insights.dim_tasks, insights.dim_cases, insights.dim_persons, insights.dim_learning_groups)
15.3 Fact Tables (Tasks, Cases, Wellbeing Check‑Ins) (insights.fact_tasks, insights.fact_cases, insights.fact_wellbeing_checkins)
---

# Orgo v3 – Database Schema Reference (Custom Tables)

## Preface

### Scope

This document is the **canonical reference for all custom Orgo v3 database tables**:

* It covers both the **operational schema** and the **Insights/analytics star‑schema** used by Orgo v3.
* It **excludes**:

  * Database system/catalog tables.
  * Migration bookkeeping (e.g. Alembic tables).
  * Any third‑party auth/session tables we might adopt later.

Other documents (e.g. Foundations, Core Services, Domain Modules, Insights / Analytics specs) may describe **how** these tables are populated or queried, but **table names and core columns are defined here** and must not diverge.

### Technology & naming assumptions

 * **Operational database:** PostgreSQL **15+**.
   *This document defines the canonical shapes for both the operational schema and the analytics star‑schema. The analytics star‑schema MAY be implemented on PostgreSQL 15+ or mirrored into an external warehouse (e.g., BigQuery, Snowflake); when not on Postgres, the same column shapes and token sets apply with warehouse‑appropriate types.*
* **Back‑end stacks (implementation‑neutral spec):**

  * **Python reference implementation:** Python **3.11.x** + SQLAlchemy 2.x.
  * **TypeScript/NestJS implementation:** NestJS (TypeScript) + ORM (e.g. TypeORM/Prisma).
* This document is **language‑agnostic**: table names, column names, and enum values are canonical and must be respected by **all** backend implementations.
* **Table naming:**

  * Table names: `snake_case` plural, optionally qualified with a schema for analytics (e.g. `insights.fact_tasks`).
  * Model/class names in examples: `PascalCase`.

    * Example: `Task` → `tasks`.

### Multi‑tenancy conventions

* Every Orgo installation can host many **organizations** (tenants).
* **Tenancy key:** `organization_id` referencing `organizations.id`.
* Rules:

  * If a record is **org‑scoped**, it has a **non‑NULL `organization_id`**.
  * If a record is **global**, `organization_id` is **NULL**.
  * Some definitional tables (e.g. workflows, labels, templates) can be either:

    * Global (shared defaults, `organization_id IS NULL`), or
    * Overridden per organization (`organization_id` filled).

### Default audit columns

Unless stated otherwise, **all business tables** have:

* `created_at` (timestamptz, NOT NULL, default `now()`)
* `updated_at` (timestamptz, NOT NULL, auto‑updated)

We don’t repeat these in every “Key columns” list unless there’s something special (like `deleted_at`, `closed_at`, etc.).

### Enum implementation

For Orgo v3, all enums listed here are implemented as PostgreSQL ENUM types on the **operational schema** with the exact value sets given in this document (not just free‑text columns). For the **Insights/analytics star‑schema** (`insights.*`), the same token sets are stored as `TEXT` columns containing the canonical values, to decouple the warehouse from OLTP enums (see Module 14 and the Insights config).

Key examples:

* `organization_status_enum = 'active' | 'suspended' | 'archived'`
* `task_status_enum = 'PENDING' | 'IN_PROGRESS' | 'ON_HOLD' | 'COMPLETED' | 'FAILED' | 'ESCALATED' | 'CANCELLED'`
* `task_priority_enum = 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'`
* `task_severity_enum = 'MINOR' | 'MODERATE' | 'MAJOR' | 'CRITICAL'`
* `visibility_enum = 'PUBLIC' | 'INTERNAL' | 'RESTRICTED' | 'ANONYMISED'`
* `task_source_enum = 'email' | 'api' | 'manual' | 'sync'`
* `notification_channel_enum = 'email' | 'sms' | 'in_app' | 'webhook'`

> Historical data where `severity = 'info'` SHALL be treated as `severity = 'MINOR'` on read.
> Historical Task/Case `source` values:
>
> * `ui` → `manual`
> * `import` → `sync`
> * `insight` → `api` (with extra metadata indicating system‑generated origin)

**JSON / API representation:**

* API payloads use lower‑case representations, e.g. `"pending"`, `"high"`, `"anonymised"`, but they MUST map 1:1 to the enums above.
* For visibility, the canonical stored value is `ANONYMISED`; JSON uses `"anonymised"` (always with an **s**, never `"anonymized"`).

---

## Module 1 – Core Platform & Multi‑Tenancy

### Organization & Profile

**Organization → Organization (table: organizations)**
Purpose: Represents a tenant using Orgo (company, school, community, team, etc.).
Key columns:

* `id` (UUID PK)
* `slug` (text, unique; short code for URLs/config, e.g. `northside-hospital`)
* `display_name` (text; human name)
* `legal_name` (text, nullable)
* `primary_domain` (text, nullable; email/web domain)
* `status` (`organization_status_enum`: `active` | `suspended` | `archived`)
* `timezone` (text; IANA TZ, e.g. `"America/New_York"`)
* `default_locale` (text; e.g. `"en"`, `"fr-CA"`)

**Organization Profile → OrganizationProfile (table: organization_profiles)**
Purpose: Stores high‑level behavioural profile for an organization (reactivity, transparency, retention, pattern sensitivity). Profile codes correspond to entries in the profiles YAML (friend_group, hospital, advocacy_group, retail_chain, military_organization, environmental_group, artist_collective, etc.). 
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id, UNIQUE; one active profile per org)
* `profile_code` (text; e.g. `friend_group`, `hospital`, `school_basketball`, `advocacy_group`)
* `reactivity_profile` (JSONB; per‑task‑type SLA targets, minutes for `LOW`/`MEDIUM`/`HIGH`/`CRITICAL`)
* `transparency_profile` (JSONB; defaults for who can see what)
* `pattern_sensitivity_profile` (JSONB; thresholds for insights/alerts)
* `retention_profile` (JSONB; log & data retention periods per category)
* `version` (integer; increments on profile changes)

---

## Module 2 – Identity & Access Control

### Users & Persons

**User Account → UserAccount (table: user_accounts)**
Purpose: Login account for a human user within a specific organization.
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id)
* `email` (text; UNIQUE within organization)
* `display_name` (text)
* `password_hash` (text, nullable for SSO‑only accounts)
* `auth_provider` (enum: `local` | `sso` | `external_only`)
* `status` (enum: `active` | `invited` | `disabled`)
* `locale` (text; optional user‑level override)
* `timezone` (text; optional user‑level override)
* `last_login_at` (timestamptz, nullable)

**Person Profile → PersonProfile (table: person_profiles)**
Purpose: Represents a person tasks are about (players, students, employees, community members) regardless of whether they have an Orgo login.
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id)
* `linked_user_id` (UUID FK → user_accounts.id, nullable; when this person also has a UserAccount)
* `external_reference` (text, nullable; e.g. student ID, employee number)
* `full_name` (text)
* `date_of_birth` (date, nullable)
* `primary_contact_email` (text, nullable)
* `primary_contact_phone` (text, nullable)
* `confidentiality_level` (enum: `normal` | `sensitive` | `highly_sensitive`; used by higher‑level visibility rules)

### Roles & Permissions

**Role → Role (table: roles)**
Purpose: Named role within an organization (e.g. `maintenance_coordinator`, `hr_officer`, `coach`, `monk`).
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id, nullable for global/system roles)
* `code` (text; unique per organization when `organization_id` NOT NULL, e.g. `ops_maintenance_coordinator`)
* `display_name` (text)
* `description` (text)
* `is_system_role` (boolean; true for built‑in, protected roles)

**Permission → Permission (table: permissions)**
Purpose: Atomic capabilities used across Orgo (e.g. `task.view_sensitive`, `workflow.edit_rules`).
Key columns:

* `id` (UUID PK)
* `code` (text; UNIQUE; stable identifier used in code)
* `description` (text)

**Role Permission → RolePermission (table: role_permissions)**
Purpose: Many‑to‑many linking roles to permissions.
Key columns:

* `id` (UUID PK)
* `role_id` (UUID FK → roles.id)
* `permission_id` (UUID FK → permissions.id)
* `granted_by_user_id` (UUID FK → user_accounts.id, nullable)
* `granted_at` (timestamptz)

**User Role Assignment → UserRoleAssignment (table: user_role_assignments)**
Purpose: Assigns roles to user accounts, optionally scoped (e.g. specific team or site).
Key columns:

* `id` (UUID PK)
* `user_id` (UUID FK → user_accounts.id)
* `role_id` (UUID FK → roles.id)
* `organization_id` (UUID FK → organizations.id)
* `scope_type` (enum: `global` | `team` | `location` | `unit` | `custom`)
* `scope_reference` (text, nullable; semantics depend on `scope_type`)
* `assigned_at` (timestamptz)
* `revoked_at` (timestamptz, nullable)

### Sessions & API Tokens

**Login Session → LoginSession (table: login_sessions)**
Purpose: Tracks user login sessions for audit and security.
Key columns:

* `id` (UUID PK)
* `user_id` (UUID FK → user_accounts.id)
* `organization_id` (UUID FK → organizations.id)
* `ip_address` (inet, nullable)
* `user_agent` (text, nullable)
* `started_at` (timestamptz)
* `ended_at` (timestamptz, nullable)
* `termination_reason` (enum: `logout` | `timeout` | `forced` | `unknown`)

**API Token → ApiToken (table: api_tokens)**
Purpose: Long‑lived tokens for programmatic access (bots, integrations).
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id)
* `owner_user_id` (UUID FK → user_accounts.id, nullable)
* `label` (text; e.g. “Maintenance monitor bot”)
* `token_hash` (text; hashed token, not plaintext)
* `scopes` (JSONB; list of permission codes or resource patterns)
* `expires_at` (timestamptz, nullable)
* `revoked_at` (timestamptz, nullable)
* `last_used_at` (timestamptz, nullable)

---

## Module 3 – Communication & Email

### Email Accounts & Role Inboxes

**Email Account Configuration → EmailAccountConfig (table: email_account_configs)**
Purpose: Connection settings for IMAP/SMTP accounts Orgo uses to read/send email.
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id)
* `label` (text; e.g. “Main HR mailbox”)
* `imap_host` (text), `imap_port` (integer), `imap_use_ssl` (boolean)
* `smtp_host` (text), `smtp_port` (integer), `smtp_use_ssl` (boolean)
* `username` (text)
* `encrypted_password` (text; encrypted at rest)
* `polling_interval_seconds` (integer; default polling cadence)
* `last_successful_poll_at` (timestamptz, nullable)
* `is_active` (boolean)

**Role Inbox → RoleInbox (table: role_inboxes)**
Purpose: Maps roles to incoming email addresses that should create/route tasks.
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id)
* `role_id` (UUID FK → roles.id)
* `email_account_config_id` (UUID FK → email_account_configs.id)
* `display_address` (text; e.g. `maintenance@org.example`)
* `is_primary` (boolean; one primary per role)
* `accept_anonymous` (boolean; if true, tasks created without a known PersonProfile)

### Messages, Threads, Attachments

**Email Thread → EmailThread (table: email_threads)**
Purpose: Logical conversation thread; groups related messages and links to primary task.
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id)
* `external_thread_key` (text; provider thread id or synthetic)
* `subject_snapshot` (text; canonical subject)
* `primary_task_id` (UUID FK → tasks.id, nullable)
* `last_message_at` (timestamptz)

**Email Message → EmailMessage (table: email_messages)**
Purpose: Normalized metadata and body for individual emails Orgo ingests or sends. Logical use in Core Services follows the EMAIL_MESSAGE model in the Core Services spec; this table is the physical storage. 
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id)
* `email_account_config_id` (UUID FK → email_account_configs.id, nullable)
* `thread_id` (UUID FK → email_threads.id, nullable)
* `message_id_header` (text, nullable; RFC822 `Message-ID`)
* `direction` (enum: `inbound` | `outbound`)
* `from_address` (text)
* `to_addresses` (text[]; array of RFC822 addresses)
* `cc_addresses` (text[], nullable)
* `bcc_addresses` (text[], nullable)
* `subject` (text)
* `received_at` (timestamptz, nullable)
* `sent_at` (timestamptz, nullable)
* `raw_headers` (text)
* `text_body` (text, nullable)
* `html_body` (text, nullable; may be truncated; full body can live in blob storage)
* `related_task_id` (UUID FK → tasks.id, nullable)
* `sensitivity` (enum: `normal` | `sensitive` | `highly_sensitive`)

**Email Attachment → EmailAttachment (table: email_attachments)**
Purpose: Metadata for email attachments, with content in external storage.
Key columns:

* `id` (UUID PK)
* `email_message_id` (UUID FK → email_messages.id)
* `file_name` (text)
* `mime_type` (text)
* `size_bytes` (bigint)
* `storage_key` (text; key/path in object store)
* `checksum` (text; e.g. SHA256)

### Email Ingestion

**Email Ingestion Batch → EmailIngestionBatch (table: email_ingestion_batches)**
Purpose: Tracks each IMAP/POP/Archive poll job for observability and retry.
Key columns:

* `id` (UUID PK)
* `email_account_config_id` (UUID FK → email_account_configs.id)
* `started_at` (timestamptz)
* `finished_at` (timestamptz, nullable)
* `message_count` (integer; messages seen in this batch)
* `status` (enum: `running` | `completed` | `failed`)
* `error_summary` (text, nullable)

**Email Processing Event → EmailProcessingEvent (table: email_processing_events)**
Purpose: Logs processing steps for an email: parsed, classified, linked, or dropped.
Key columns:

* `id` (UUID PK)
* `email_message_id` (UUID FK → email_messages.id)
* `event_type` (enum: `parsed` | `classification_succeeded` | `classification_failed` | `task_created` | `linked_to_existing_task` | `dropped`)
* `details` (JSONB; e.g. classifier scores, matching rules)
* `created_at` (timestamptz)

---

## Module 4 – Task & Workflow Engine

### Tasks & Comments

**Task → Task (table: tasks)**
Purpose: Central unit of work in Orgo; all workflows (maintenance, HR, education, etc.) map to tasks with metadata. The canonical Task field set and enums are locked in the Foundations doc and reused by domain modules and core services.
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id)
* `case_id` (UUID FK → cases.id, nullable; ties this task to a generic Case)
* `type` (text; domain‑level type, e.g. `maintenance`, `hr_case`, `education_support`, `it_support`, `operations`, `generic`)
* `category` (enum: `request` | `incident` | `update` | `report` | `distribution`)
* `subtype` (text; domain‑specific, e.g. `plumbing`, `harassment`, `attendance`)
* `label` (text; canonical information label `<base>.<category><subcategory>.<horizontal_role>`)
* `title` (text)
* `description` (text)
* `status` (`task_status_enum`: `PENDING` | `IN_PROGRESS` | `ON_HOLD` | `COMPLETED` | `FAILED` | `ESCALATED` | `CANCELLED`)
* `priority` (`task_priority_enum`: `LOW` | `MEDIUM` | `HIGH` | `CRITICAL`)
* `severity` (`task_severity_enum`: `MINOR` | `MODERATE` | `MAJOR` | `CRITICAL`; **NOT NULL**, default `MINOR` if unspecified)
* `visibility` (`visibility_enum`: `PUBLIC` | `INTERNAL` | `RESTRICTED` | `ANONYMISED`)
* `source` (`task_source_enum`: `email` | `api` | `manual` | `sync`)
* `created_by_user_id` (UUID FK → user_accounts.id, nullable)
* `requester_person_id` (UUID FK → person_profiles.id, nullable)
* `owner_role_id` (UUID FK → roles.id, nullable; primary owning role)
* `owner_user_id` (UUID FK → user_accounts.id, nullable; direct owner)
* `assignee_role` (text, nullable; denormalized role identifier such as `"Ops.Maintenance"`, aligned with the label system)
* `reactivity_time` (interval, nullable; SLA/expected response time)
* `reactivity_deadline_at` (timestamptz, nullable; typically `created_at + reactivity_time` under the active org profile)
* `due_at` (timestamptz, nullable)
* `escalation_level` (integer, NOT NULL, default 0; 0 = no escalation, 1+ = escalation depth)
* `closed_at` (timestamptz, nullable)
* `metadata` (JSONB; domain‑specific fields, e.g. asset_id, group_id, location)

> `owner_role_id` / `owner_user_id` are normalized FKs; `assignee_role` is a denormalized label string used for routing/label semantics and cross‑system references.
> Confidentiality is handled via **visibility + org/person/case confidentiality**, not a task‑local `confidentiality_level` field.

**Task Assignment → TaskAssignment (table: task_assignments)**
Purpose: History of which roles/users have been assigned to a task (primary & secondary).
Key columns:

* `id` (UUID PK)
* `task_id` (UUID FK → tasks.id)
* `assigned_role_id` (UUID FK → roles.id, nullable)
* `assigned_user_id` (UUID FK → user_accounts.id, nullable)
* `is_primary` (boolean)
* `assigned_at` (timestamptz)
* `unassigned_at` (timestamptz, nullable)
* `assignment_reason` (text, nullable)

**Task Event → TaskEvent (table: task_events)**
Purpose: Append‑only event log for task lifecycle, used for audit and analytics.
Key columns:

* `id` (UUID PK)
* `task_id` (UUID FK → tasks.id)
* `organization_id` (UUID FK → organizations.id)
* `event_type` (enum: `created` | `status_changed` | `priority_changed` | `ownership_changed` | `comment_added` | `email_linked` | `escalated` | `deadline_updated` | `metadata_updated`)
* `old_value` (JSONB, nullable)
* `new_value` (JSONB, nullable)
* `actor_user_id` (UUID FK → user_accounts.id, nullable)
* `actor_role_id` (UUID FK → roles.id, nullable)
* `origin` (enum: `ui` | `api` | `email` | `system_rule`)
* `created_at` (timestamptz)

**Task Comment → TaskComment (table: task_comments)**
Purpose: Comment/discussion entries attached to tasks, with visibility control.
Key columns:

* `id` (UUID PK)
* `task_id` (UUID FK → tasks.id)
* `author_user_id` (UUID FK → user_accounts.id, nullable for system notes)
* `visibility` (enum: `internal_only` | `requester_visible` | `org_wide`)
* `body` (text)

> `TaskComment.visibility` is a **comment‑level audience flag**, distinct from the global `visibility_enum` used on Tasks/Cases.

### Routing Rules

**Routing Rule → RoutingRule (table: routing_rules)**
Purpose: Declarative rules to decide **who** initially owns new tasks (by role or user) based on type/category/labels.
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id, nullable for global defaults)
* `name` (text; human label, e.g. “Default HR sensitive complaints routing”)
* `task_type` (text, nullable; e.g. `maintenance`, `hr_case`)
* `task_category` (enum: `request` | `incident` | `update` | `report` | `distribution`, nullable)
* `label_codes` (text[]; optional required labels, e.g. `['anonymous']`)
* `priority_min` (`task_priority_enum`, nullable)
* `target_role_id` (UUID FK → roles.id, nullable)
* `target_user_id` (UUID FK → user_accounts.id, nullable)
* `is_fallback` (boolean; used when no more specific rule matches)
* `weight` (integer; for tie‑breaking between matching rules)

### Workflow Definitions & Instances

**Workflow Definition → WorkflowDefinition (table: workflow_definitions)**
Purpose: Canonical definition of a workflow (states, transitions, guards) stored as JSON, optionally org‑specific.
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id, nullable; NULL = global default)
* `code` (text; UNIQUE within org or globally, e.g. `maintenance_default`, `hr_sensitive_case`)
* `name` (text)
* `description` (text)
* `definition_blob` (JSONB; normalized workflow spec: states, transitions, actions)
* `is_active` (boolean)
* `version` (integer)

**Workflow Instance → WorkflowInstance (table: workflow_instances)**
Purpose: Runtime instance of a workflow bound to a task.
Key columns:

* `id` (UUID PK)
* `workflow_definition_id` (UUID FK → workflow_definitions.id)
* `task_id` (UUID FK → tasks.id)
* `organization_id` (UUID FK → organizations.id)
* `current_state` (text; key from definition)
* `status` (enum: `running` | `completed` | `cancelled`)
* `started_at` (timestamptz)
* `finished_at` (timestamptz, nullable)

**Workflow Transition Event → WorkflowTransitionEvent (table: workflow_transition_events)**
Purpose: Logs transitions between workflow states, including who triggered them.
Key columns:

* `id` (UUID PK)
* `workflow_instance_id` (UUID FK → workflow_instances.id)
* `task_id` (UUID FK → tasks.id)
* `from_state` (text, nullable when first state)
* `to_state` (text)
* `trigger` (text; e.g. `submit`, `approve`, `close`)
* `actor_user_id` (UUID FK → user_accounts.id, nullable)
* `actor_role_id` (UUID FK → roles.id, nullable)
* `reason` (text, nullable)
* `occurred_at` (timestamptz)

### Escalation & SLA

**Escalation Policy → EscalationPolicy (table: escalation_policies)**
Purpose: Multi‑step escalation plans for certain task types/categories.
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id, nullable for global policies)
* `task_type` (text, nullable)
* `category` (enum: `request` | `incident` | `update` | `report` | `distribution`, nullable)
* `policy_code` (text; e.g. `standard_hr_sensitive`, unique per org)
* `definition` (JSONB; steps with timing + target roles/users/channels)
* `is_default` (boolean)
* `version` (integer)

**Escalation Instance → EscalationInstance (table: escalation_instances)**
Purpose: Runtime execution of an escalation policy for a particular task.
Key columns:

* `id` (UUID PK)
* `task_id` (UUID FK → tasks.id)
* `escalation_policy_id` (UUID FK → escalation_policies.id)
* `current_step_index` (integer)
* `status` (enum: `idle` | `scheduled` | `in_progress` | `completed` | `cancelled`)
* `next_fire_at` (timestamptz, nullable)
* `started_at` (timestamptz)
* `completed_at` (timestamptz, nullable)

**Escalation Event → EscalationEvent (table: escalation_events)**
Purpose: Logs each concrete escalation action taken for a task.
Key columns:

* `id` (UUID PK)
* `escalation_instance_id` (UUID FK → escalation_instances.id)
* `task_id` (UUID FK → tasks.id)
* `step_index` (integer)
* `action_type` (enum: `notify_role` | `notify_user` | `auto_reassign` | `auto_close` | `raise_severity`)
* `action_payload` (JSONB; details: which role/user, which channel)
* `executed_at` (timestamptz)
* `success` (boolean)
* `error_message` (text, nullable)

---

## Module 5 – Configuration, Parameters & Feature Flags

**Parameter Override → ParameterOverride (table: parameter_overrides)**
Purpose: Physical storage of configuration knobs (parameters) per org, aligned with the Global Parameter Reference. 
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id, nullable for global defaults)
* `module_code` (text; e.g. `core`, `maintenance`, `hr`, `education`, `insights`)
* `parameter_key` (text; stable identifier, e.g. `reactivity.hr.critical_sla_minutes`)
* `value` (JSONB; typed via param spec: number/string/enum/object)
* `source` (enum: `default` | `org_override` | `profile` | `runtime`)
* `effective_from` (timestamptz)

**Feature Flag → FeatureFlag (table: feature_flags)**
Purpose: Toggles to roll out or restrict features per organization.
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id, nullable for global flags)
* `code` (text; e.g. `insights_cyclic_reviews_v2`)
* `description` (text)
* `enabled` (boolean)
* `rollout_strategy` (JSONB; e.g. percentage, subset of roles)
* `enabled_from` (timestamptz, nullable)
* `disabled_at` (timestamptz, nullable)

---

## Module 6 – Labeling & Classification

### Canonical labels vs classification tags

* `tasks.label` and `cases.label` store the **canonical information label** of the form
  `<base>.<category><subcategory>.<horizontal_role>`,
  as defined in the cross‑document Orgo v3 semantics.
* The `label_definitions` and `entity_labels` tables are used for **additional classification tags** (e.g. `self_harm_risk`, `equipment_failure`, `conflict`) that are attached to tasks, people, groups, and cases.
* Canonical labels are 1‑per‑entity (Task/Case); classification tags are 0‑to‑many per entity.

**Label Definition → LabelDefinition (table: label_definitions)**
Purpose: Standardized labels used for classification/pattern detection.
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id, nullable for global labels)
* `code` (text; unique per org/global, e.g. `anonymous`, `equipment_failure`)
* `display_name` (text)
* `description` (text)
* `category` (text; e.g. `risk`, `topic`, `visibility`)
* `color_hint` (text, nullable; hex or name for UI)

**Entity Label → EntityLabel (table: entity_labels)**
Purpose: Attaches labels to different entities (tasks, people, groups, cases) in a uniform way.
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id)
* `label_id` (UUID FK → label_definitions.id)
* `entity_type` (text; e.g. `task`, `person`, `learning_group`, `case`, `hr_case`)
* `entity_id` (UUID; ID in the corresponding table)
* `applied_by_user_id` (UUID FK → user_accounts.id, nullable)
* `applied_at` (timestamptz)

---

## Module 7 – Notifications

**Notification Template → NotificationTemplate (table: notification_templates)**
Purpose: Templates for notifications per org and channel (subject/body or payload format).
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id, nullable for global templates)
* `code` (text; unique per org, e.g. `task_created_requester`, `task_escalated_owner`)
* `channel` (`notification_channel_enum`: `email` | `sms` | `in_app` | `webhook`)
* `subject_template` (text, nullable; email‑only)
* `body_template` (text; text or JSON payload template)
* `is_active` (boolean)
* `version` (integer)

**Notification → Notification (table: notifications)**
Purpose: Individual notification instances queued/sent to users or external targets.
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id)
* `channel` (`notification_channel_enum`: `email` | `sms` | `in_app` | `webhook`)
* `recipient_user_id` (UUID FK → user_accounts.id, nullable)
* `recipient_address` (text, nullable; email/phone/webhook URL/device token)
* `template_id` (UUID FK → notification_templates.id, nullable if custom payload)
* `payload` (JSONB; merged data ready for the channel)
* `status` (enum: `queued` | `sent` | `failed` | `cancelled`)
* `related_task_id` (UUID FK → tasks.id, nullable)
* `queued_at` (timestamptz)
* `sent_at` (timestamptz, nullable)
* `failed_at` (timestamptz, nullable)
* `error_message` (text, nullable)

+  Channel values in both tables are stored as lower-case tokens and map 1:1 to the global `NOTIFICATION_CHANNEL` enum (`EMAIL`, `SMS`, `IN_APP`, `WEBHOOK`) used in configs and services. Mobile push, if implemented, MUST be modelled via `IN_APP` plus client-side delivery; a distinct `PUSH` channel is not supported.


---

## Module 8 – Logging, Audit & Observability

**Activity Log → ActivityLog (table: activity_logs)**
Purpose: Generic, non‑security activity log for user/system actions (for audit & insights).
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id)
* `user_id` (UUID FK → user_accounts.id, nullable)
* `session_id` (UUID FK → login_sessions.id, nullable)
* `actor_type` (enum: `user` | `system`)
* `action` (text; e.g. `task_viewed`, `config_updated`, `report_run`)
* `target_type` (text; e.g. `task`, `workflow_definition`, `person`)
* `target_id` (UUID, nullable)
* `details` (JSONB)

**Security Event → SecurityEvent (table: security_events)**
Purpose: High‑importance security events (failed logins, permission changes, suspicious exports).
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id, nullable for system‑wide events)
* `user_id` (UUID FK → user_accounts.id, nullable)
* `event_type` (enum: `failed_login` | `permission_escalation` | `api_abuse` | `data_export` | `config_change`)
* `ip_address` (inet, nullable)
* `user_agent` (text, nullable)
* `details` (JSONB)
* `severity` (enum: `low` | `medium` | `high` | `critical`)

**System Metric Snapshot → SystemMetricSnapshot (table: system_metric_snapshots)**
Purpose: Periodic snapshots of aggregated metrics for long‑term trends at low cardinality.
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id, nullable)
* `period_start` (timestamptz)
* `period_end` (timestamptz)
* `metrics` (JSONB; e.g. `tasks_created`, `escalations_triggered`, `avg_response_time_minutes`)

---

## Module 9 – Cases (Generic)

**Case → Case (table: cases)**
Purpose: Generic case container that groups tasks, patterns, and context across domains (HR, maintenance incidents, education support, advocacy, etc.). JSON contracts and lifecycle semantics are defined in the Cyclic Overview / JSON doc; this table is the physical backing.
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id)
* `source_type` (enum: `email` | `api` | `manual` | `sync`; same semantics as `tasks.source`)
* `source_reference` (text, nullable; external id or URI)
* `label` (text; canonical information label `<base>.<category><subcategory>.<horizontal_role>`)
* `title` (text)
* `description` (text)
* `status` (enum: `open` | `in_progress` | `resolved` | `archived`; canonical case lifecycle)
* `severity` (`task_severity_enum`: `MINOR` | `MODERATE` | `MAJOR` | `CRITICAL`)
* `reactivity_time` (interval, nullable; expected responsiveness window for the case)
* `origin_vertical_level` (integer; e.g. 1, 10, 100, 1000)
* `origin_role` (text; e.g. `"Ops.Maintenance"`, `"HR.CaseOfficer"`)
* `tags` (text[]; high‑level tags, e.g. `['harassment','classroom']`)
* `location` (JSONB; structure holding physical/organizational location info)
* `metadata` (JSONB; includes `pattern_sensitivity`, `review_frequency`, `notification_scope`, `visibility`, `escalation_path[]`, `profile_id`, and other case‑level settings)

> Links from cases to tasks and related cases are represented via join tables and domain‑specific link tables (e.g. `tasks.case_id`, `hr_case_task_links`, and optional generic `case_case_links` if introduced later).
> Historical `source_type` values such as `email_thread`, `import`, `insight` SHOULD be mapped during migration to `email`, `sync`, or `api` respectively.

---

## Module 10 – Domain: Operations & Maintenance

**Maintenance Asset → MaintenanceAsset (table: maintenance_assets)**
Purpose: Assets that can have maintenance tasks (buildings, rooms, vehicles, equipment).
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id)
* `code` (text; unique per org, e.g. `BLDG_A_F2_R210`)
* `name` (text)
* `category` (text; e.g. `building` | `room` | `vehicle` | `equipment`)
* `location_description` (text, nullable)
* `metadata` (JSONB; vendor, serial, capacity, etc.)
* `is_active` (boolean)

**Maintenance Task Link → MaintenanceTaskLink (table: maintenance_task_links)**
Purpose: Connects generic tasks to maintenance context (asset and optional external work order).
Key columns:

* `id` (UUID PK)
* `task_id` (UUID FK → tasks.id)
* `asset_id` (UUID FK → maintenance_assets.id)
* `work_order_reference` (text, nullable; external CMMS id)
* `priority_override` (`task_priority_enum`, nullable)

**Maintenance Calendar Slot → MaintenanceCalendarSlot (table: maintenance_calendar_slots)**
Purpose: Scheduled work slots for maintenance tasks (for planning, scheduling, and pattern analysis).
Key columns:

* `id` (UUID PK)
* `task_id` (UUID FK → tasks.id)
* `assigned_user_id` (UUID FK → user_accounts.id, nullable)
* `start_at` (timestamptz)
* `end_at` (timestamptz)
* `status` (enum: `planned` | `in_progress` | `completed` | `cancelled`)

---

## Module 11 – Domain: HR & Wellbeing

**HR Case → HrCase (table: hr_cases)**
Purpose: HR‑specific extension of a generic Case for sensitive matters (harassment, conflict, performance, etc.).
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id)
* `case_id` (UUID FK → cases.id, UNIQUE; 1‑to‑1 refinement of a generic Case)
* `case_code` (text; unique per org, e.g. `HR-2025-0043`)
* `title` (text)
  *(usually mirrors `cases.title`, but HR can override or anonymise)*
* `description` (text)
  *(HR‑specific narrative; may be more detailed or more anonymised than generic `cases.description`)*
* `status` (enum: `open` | `under_review` | `resolved` | `dismissed`; HR pipeline state, distinct from generic `cases.status`)
* `confidentiality_level` (enum: `sensitive` | `highly_sensitive`; drives stricter visibility and handling rules)
* `case_owner_role_id` (UUID FK → roles.id)
* `case_owner_user_id` (UUID FK → user_accounts.id, nullable)
* `primary_task_id` (UUID FK → tasks.id, nullable)
* `opened_at` (timestamptz)
* `closed_at` (timestamptz, nullable)

**HR Case Participant → HrCaseParticipant (table: hr_case_participants)**
Purpose: People involved in an HR case (complainant, respondent, witnesses, advocates).
Key columns:

* `id` (UUID PK)
* `hr_case_id` (UUID FK → hr_cases.id)
* `person_id` (UUID FK → person_profiles.id)
* `role_in_case` (enum: `complainant` | `respondent` | `witness` | `advocate` | `other`)
* `notes` (text, nullable)

**HR Case Task Link → HrCaseTaskLink (table: hr_case_task_links)**
Purpose: Links generic tasks (meetings, investigations, communications) to an HR case.
Key columns:

* `id` (UUID PK)
* `hr_case_id` (UUID FK → hr_cases.id)
* `task_id` (UUID FK → tasks.id)
* `link_type` (text; e.g. `investigation`, `communication`, `followup`, `support`)

**Wellbeing Check‑In → WellbeingCheckin (table: wellbeing_checkins)**
Purpose: Structured wellbeing check‑ins (survey or manual) tied to people/groups for early risk detection.
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id)
* `person_id` (UUID FK → person_profiles.id, nullable for anonymous)
* `submitted_by_user_id` (UUID FK → user_accounts.id, nullable)
* `context` (text; e.g. `basketball_team`, `residence`, `study_group`)
* `score` (integer; e.g. 1–10)
* `tags` (text[]; e.g. `['stress', 'sleep']`)
* `notes` (text, nullable)
* `related_task_id` (UUID FK → tasks.id, nullable)

---

## Module 12 – Domain: Education & Groups

**Learning Group → LearningGroup (table: learning_groups)**
Purpose: Represents a class/team/group of learners (school class, basketball team, study group).
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id)
* `code` (text; unique per org, e.g. `CLASS_6A`, `BASKETBALL_U15`)
* `name` (text)
* `description` (text, nullable)
* `category` (text; e.g. `school_class` | `sports_team` | `study_circle`)
* `advisor_role_id` (UUID FK → roles.id, nullable)

**Learning Group Membership → LearningGroupMembership (table: learning_group_memberships)**
Purpose: Links people to learning groups with roles (student, player, coach, parent).
Key columns:

* `id` (UUID PK)
* `learning_group_id` (UUID FK → learning_groups.id)
* `person_id` (UUID FK → person_profiles.id)
* `role` (enum: `student` | `player` | `parent` | `coach` | `teacher` | `mentor`)
* `joined_at` (timestamptz)
* `left_at` (timestamptz, nullable)

**Education Task Link → EducationTaskLink (table: education_task_links)**
Purpose: Associates tasks with educational context (groups, individuals, education‑related events).
Key columns:

* `id` (UUID PK)
* `task_id` (UUID FK → tasks.id)
* `learning_group_id` (UUID FK → learning_groups.id, nullable)
* `person_id` (UUID FK → person_profiles.id, nullable)
* `context_note` (text, nullable; e.g. `attendance`, `performance`, `conflict`)

---

## Module 13 – Offline & Sync

**Offline Node → OfflineNode (table: offline_nodes)**
Purpose: Represents a node/device that can operate offline (SQLite) and sync with central Orgo.
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id)
* `node_identifier` (text; unique, e.g. hostname + install id)
* `description` (text, nullable)
* `status` (enum: `active` | `inactive` | `retired`)
* `last_sync_at` (timestamptz, nullable)

**Sync Session → SyncSession (table: sync_sessions)**
Purpose: Tracks each synchronization session between an offline node and central Postgres.
Key columns:

* `id` (UUID PK)
* `offline_node_id` (UUID FK → offline_nodes.id)
* `direction` (enum: `upload` | `download` | `bidirectional`)
* `started_at` (timestamptz)
* `finished_at` (timestamptz, nullable)
* `status` (enum: `running` | `completed` | `failed`)
* `summary` (JSONB; counts of records created/updated/deleted)
* `error_message` (text, nullable)

**Sync Conflict → SyncConflict (table: sync_conflicts)**
Purpose: Conflicts discovered during sync (e.g. concurrent edits); used for manual or automated resolution.
Key columns:

* `id` (UUID PK)
* `sync_session_id` (UUID FK → sync_sessions.id)
* `entity_type` (text; e.g. `task`, `task_event`, `person_profile`)
* `entity_id` (UUID)
* `server_version` (JSONB; snapshot before resolution)
* `client_version` (JSONB; snapshot from offline node)
* `resolution_strategy` (enum: `server_wins` | `client_wins` | `manual_review` | `merged`)
* `resolved` (boolean)
* `resolved_at` (timestamptz, nullable)
* `resolved_by_user_id` (UUID FK → user_accounts.id, nullable)

**Email Archive Import Batch → EmailArchiveImportBatch (table: email_archive_import_batches)**
Purpose: Tracks imports of offline email archives (.pst/.mbox) into Orgo.
Key columns:

* `id` (UUID PK)
* `organization_id` (UUID FK → organizations.id)
* `source_type` (enum: `pst` | `mbox` | `eml_folder`)
* `source_path` (text; path/URI to archive)
* `started_at` (timestamptz)
* `finished_at` (timestamptz, nullable)
* `status` (enum: `running` | `completed` | `failed`)
* `messages_imported` (integer)
* `error_summary` (text, nullable)

**Imported Message Mapping → ImportedMessageMapping (table: imported_message_mappings)**
Purpose: Maps original archive message identifiers to Orgo `email_messages` IDs.
Key columns:

* `id` (UUID PK)
* `email_archive_import_batch_id` (UUID FK → email_archive_import_batches.id)
* `external_message_identifier` (text; e.g. PST entry ID)
* `email_message_id` (UUID FK → email_messages.id)

---

## Module 14 – Analytics / Insights Star‑Schema

All analytics tables live in the **`insights` schema** of the primary PostgreSQL database (or a dedicated analytics database with the same schema names). This module defines the **canonical fact and dimension tables** used by the Insights layer; configuration and retention are defined in the Insights Module Config.

In line with the Insights config, **enum‑like fields in this schema are stored as `TEXT` columns** whose values are the canonical enum tokens from the operational schema (`TASK_STATUS`, `TASK_PRIORITY`, `TASK_SEVERITY`, `VISIBILITY`, etc.). They are not Postgres ENUMs in the warehouse.

### Dimensions

**Analytics Date Dimension → DimDate (table: insights.dim_dates)**
Purpose: Calendar/date dimension used for grouping facts by day.
Key columns:

* `date_key` (date PK; e.g. `2025-03-14`)
* `year` (integer)
* `quarter` (integer; 1–4)
* `month` (integer; 1–12)
* `month_name` (text)
* `week_of_year` (integer)
* `day_of_week` (integer; 1=Monday–7=Sunday)
* `day_name` (text)
* `is_weekend` (boolean)

**Analytics Organization Dimension → DimOrganization (table: insights.dim_organizations)**
Purpose: Organization attributes used in reports.
Key columns:

* `organization_id` (UUID PK; FK → organizations.id)
* `slug` (text)
* `display_name` (text)
* `org_type` (text; optional, e.g. `hospital`, `school`, `club`)
* `timezone` (text)
* `active_from` (date)
* `active_to` (date, nullable)

**Analytics Task Dimension → DimTask (table: insights.dim_tasks)**
Purpose: Denormalized view of tasks for reporting (slowly changing dimension).
Key columns:

* `task_id` (UUID PK; FK → tasks.id)
* `organization_id` (UUID FK → organizations.id)
* `case_id` (UUID FK → cases.id, nullable)
* `label` (text; canonical label)
* `type` (text)
* `category` (text)
* `subtype` (text, nullable)
* `priority` (text; one of `LOW`, `MEDIUM`, `HIGH`, `CRITICAL`)
* `severity` (text; one of `MINOR`, `MODERATE`, `MAJOR`, `CRITICAL`)
* `visibility` (text; one of `PUBLIC`, `INTERNAL`, `RESTRICTED`, `ANONYMISED`)
* `source` (text; one of `email`, `api`, `manual`, `sync`)
* `assignee_role` (text, nullable)
* `created_at` (timestamptz)
* `closed_at` (timestamptz, nullable)
* `current_status` (text; one of `PENDING`, `IN_PROGRESS`, `ON_HOLD`, `COMPLETED`, `FAILED`, `ESCALATED`, `CANCELLED`)

**Analytics Case Dimension → DimCase (table: insights.dim_cases)**
Purpose: Denormalized view of cases for reporting.
Key columns:

* `case_id` (UUID PK; FK → cases.id)
* `organization_id` (UUID FK → organizations.id)
* `label` (text)
* `title` (text)
* `status` (text; one of `open`, `in_progress`, `resolved`, `archived`)
* `severity` (text; one of `MINOR`, `MODERATE`, `MAJOR`, `CRITICAL`)
* `origin_vertical_level` (integer)
* `origin_role` (text)
* `opened_at` (timestamptz)
* `closed_at` (timestamptz, nullable)

**Analytics Person Dimension → DimPerson (table: insights.dim_persons)**
Purpose: Basic person attributes for reporting on individuals.
Key columns:

* `person_id` (UUID PK; FK → person_profiles.id)
* `organization_id` (UUID FK → organizations.id)
* `full_name` (text)
* `external_reference` (text, nullable)
* `confidentiality_level` (enum: `normal` | `sensitive` | `highly_sensitive`)

**Analytics Group Dimension → DimLearningGroup (table: insights.dim_learning_groups)**
Purpose: Group attributes (class/team/etc.) used in Insights.
Key columns:

* `learning_group_id` (UUID PK; FK → learning_groups.id)
* `organization_id` (UUID FK → organizations.id)
* `code` (text)
* `name` (text)
* `category` (text)

### Facts

**Task Fact → FactTask (table: insights.fact_tasks)**
Purpose: One row per task capturing core lifecycle metrics for reporting.
Key columns:

* `id` (bigserial PK)
* `task_id` (UUID FK → tasks.id)
* `organization_id` (UUID FK → organizations.id)
* `created_date_key` (date FK → insights.dim_dates.date_key)
* `closed_date_key` (date FK → insights.dim_dates.date_key, nullable)
* `current_status` (text; one of `PENDING`, `IN_PROGRESS`, `ON_HOLD`, `COMPLETED`, `FAILED`, `ESCALATED`, `CANCELLED`)
* `priority` (text; one of `LOW`, `MEDIUM`, `HIGH`, `CRITICAL`)
* `severity` (text; one of `MINOR`, `MODERATE`, `MAJOR`, `CRITICAL`)
* `source` (text; one of `email`, `api`, `manual`, `sync`)
* `time_to_first_response_seconds` (bigint, nullable)
* `time_to_completion_seconds` (bigint, nullable)
* `escalation_count` (integer, default 0)
* `comment_count` (integer, default 0)

**Case Fact → FactCase (table: insights.fact_cases)**
Purpose: One row per case with lifecycle metrics and link counts.
Key columns:

* `id` (bigserial PK)
* `case_id` (UUID FK → cases.id)
* `organization_id` (UUID FK → organizations.id)
* `opened_date_key` (date FK → insights.dim_dates.date_key)
* `closed_date_key` (date FK → insights.dim_dates.date_key, nullable)
* `status` (text; one of `open`, `in_progress`, `resolved`, `archived`)
* `severity` (text; one of `MINOR`, `MODERATE`, `MAJOR`, `CRITICAL`)
* `linked_task_count` (integer, default 0)
* `escalation_count` (integer, default 0)
* `review_count` (integer, default 0)

**Wellbeing Check‑In Fact → FactWellbeingCheckin (table: insights.fact_wellbeing_checkins)**
Purpose: One row per wellbeing check‑in, tied to person/group and time.
Key columns:

* `id` (bigserial PK)
* `checkin_id` (UUID FK → wellbeing_checkins.id)
* `organization_id` (UUID FK → organizations.id)
* `person_id` (UUID FK → person_profiles.id, nullable)
* `learning_group_id` (UUID FK → learning_groups.id, nullable)
* `date_key` (date FK → insights.dim_dates.date_key)
* `score` (integer)
* `tags` (text[])
* `related_case_id` (UUID FK → cases.id, nullable)
* `related_task_id` (UUID FK → tasks.id, nullable)

===== END 1-orgo-database-schema-reference.md (#0001) =====

===== BEGIN 2-orgo-documentation-index.md (#0002) =====
﻿<!-- INDEX: Doc 2 – Foundations, Locked Variables & Operational Checklists -->
Index

Role of this document in the Orgo set

Orgo mental model (orientation)
1.1 Multi‑tenant backbone
1.2 Signals → Cases & Tasks
1.3 Label system (how routing works)
1.4 Domain modules
1.5 Profiles, Insights & guardrails
1.6 What Orgo is (and is not)

Global invariants & enums (locked)
2.1 Environments (ENVIRONMENT)
2.2 Multi‑tenancy & identity invariants
2.3 Task lifecycle (TASK_STATUS)
2.4 Case lifecycle (CASE_STATUS)
2.5 Priority & severity (TASK_PRIORITY, TASK_SEVERITY)
2.6 Visibility & privacy (VISIBILITY, COMMENT_VISIBILITY)
2.7 Log categories & levels (LOG_CATEGORY, LOG_LEVEL)
2.8 Notification channels & scope (NOTIFICATION_CHANNEL, NOTIFICATION_SCOPE)
2.9 Canonical label string format
2.10 Canonical Task field set (JSON contract)
2.11 Canonical Case field skeleton

Configuration system (YAML‑based, environment‑aware)
3.1 Directory layout
3.2 Common metadata & validation
3.3 Database config
3.4 Email config
3.5 Logging config

Core Services – contracts & checklists
4.1 Workflow Engine
4.2 Email Gateway
4.3 Task Handler
4.4 Notification Service
4.5 Persistence & offline sync
4.6 Logging & security hooks

Domain Modules – position & invariants
5.1 Directory & naming
5.2 Domain config rules
5.3 Handler hooks (behaviour)

Organization profiles & behavioural tuning
6.1 Profile schema (summary)
6.2 Example profile mapping

Insights & cyclic overview integration

Guardrails – visibility, audit, compliance

Testing & operational checklists

Summary – what this document locks



# Orgo v3 – Doc 2/8

**Foundations, Locked Variables & Operational Checklists**

---

## 0. Role of this document in the Orgo set

This document is the **foundation layer** for Orgo v3. It defines:

* The **global invariants** Orgo relies on (multi‑tenancy, identity model).
* The **locked enums and canonical field sets** for Tasks, Cases, labels, logging, and notifications.
* How **configuration** is structured/validated across environments.
* The **contracts + checklists** that Core Services and Domain Modules must respect.
* How **profiles, insights, and guardrails** plug into the platform.

It is implementation‑agnostic (TS/NestJS, Python, etc.) and sits under Docs:

* **Doc 1 – Database Schema Reference (Custom Tables)** – physical schema and enums.
* **Doc 3 – Domain Modules (Orgo v3)** – domain adapters over the core Task/Case engine.
* **Doc 4 – Functional Code‑Name Inventory** – mapping from features to services/jobs/hooks.
* **Doc 5 – Core Services Specification** – detailed headless services (email, tasks, workflows, logging).
* **Doc 6 – Insights Module Config Parameters** and the **profiles YAML** – analytics & behavioural profiles.
* **Doc 8 – Cyclic Overview & Universal Flow Rules** – label semantics, JSON contracts, cyclic reviews.

If anything here conflicts with **Doc 1** (schema) or the actual DB migrations, **Doc 1 wins** and this doc must be updated.

The intended conflict-resolution order across the Orgo v3 spec is:

1. **Doc 1 – Database Schema Reference** (physical tables & enums).
2. **Doc 2 – Foundations (this document)** (canonical enums, Task/Case JSON field sets, global invariants).
3. **Doc 8 – Cyclic Overview & Universal Flow Rules** (label semantics, lifecycles, flow).
4. Domain-specific and implementation docs (Docs 3–7, code inventories).

Lower-numbered docs must not be overridden by higher-numbered ones.

---

## 1. Orgo mental model (non‑normative orientation)

This section explains how the rest of the spec hangs together. It is descriptive, not a place to introduce new enums.

### 1.1 Multi‑tenant backbone

* Orgo is **multi‑tenant** – one deployment serves many organizations.
* Every org is a row in `organizations`, identified by `organization_id` with timezone, locale, status, and a linked **organization profile**.
* Every record that “belongs to” an org (email, task, case, profile, notification, log, etc.) carries `organization_id` for isolation.
* Two key identity concepts:

  * **User accounts** (`user_accounts`) – who logs into Orgo.
  * **Person profiles** (`person_profiles`) – who things are *about* (students, players, employees, community members), regardless of login.

Permissions are expressed in terms of **roles** and **permissions** attached to user accounts, with optional scoping by team/location.

### 1.2 Signals → Cases & Tasks

Orgo’s core job is to **ingest messy signals and turn them into structured work**:

* **Signals** come from:

  * Email (`email_messages` + `email_threads`), including attachments and classifier metadata.
  * HTTP APIs / UIs (`TaskController.createTask`, domain endpoints).
  * Offline imports & sync (`offline_nodes`, `sync_sessions`, `email_archive_import_batches`).

* Signals pass through the **Email Gateway** and **Workflow Engine**, which decide:

  * Whether to **open a Case** (`cases`),
  * Whether to **create a Task** (`tasks`),
  * Which **domain** (`type`), **category** (`request/incident/...`), and **role** should own it.

The **Task** is the **canonical unit of work**, defined once in Doc 1 and reused everywhere; **Cases** are long‑lived containers that group Tasks, context and patterns.

### 1.3 Label system (how routing works)

Every Case and Task carries a **structured label**:

```text
<base>.<category><subcategory>.<horizontal_role>
```

Example: `100.94.Operations.Safety`:

* `100` = broadcast to department heads (vertical level).
* `.9` = Crisis & emergency information.
* `.4` = Report.
* `Operations.Safety` = horizontal role (functional area).

This label informs:

* **Routing** – which queues/roles the work goes to.
* **Visibility default** – how sensitive it is.
* **Analytics & patterns** – what “kind” of incident it is.

Special bases `10`, `100`, `1000` are **broadcasts**. They are **informational by default** – they do not automatically spawn mandatory Tasks unless a workflow rule says so.

### 1.4 Domain modules

Domain modules (Maintenance, HR, Education, etc.):

* Do **not** own their own task tables or lifecycles.
* Are thin adapters over the global `Task`/`Case` model:

  * A config file `<domain>_module.yaml` (allowed categories, subtypes, email patterns, routing hints).
  * A handler `<domain>_handler.py` with hooks such as `on_task_create`, `on_task_update`.

They plug into the **central Task handler + Workflow Engine**; all domain behaviour is expressed via config, metadata and hooks, not separate schemas.

### 1.5 Profiles, Insights & guardrails

* **Profiles** (friend group, hospital, advocacy group, retail chain, military org, environmental group, artist collective, etc.) define **reactivity, transparency, review cadence, retention, pattern sensitivity, logging depth and automation** for an organization.
* **Insights** (star schema, ETL/Airflow, pattern detection) continuously scan Tasks/Cases, wellbeing check‑ins, groups, etc., and feed patterns back as work items and audit Cases.
* **Guardrails** – visibility enums, logging/audit tables, security events and export rules – ensure Orgo is safe for high‑sensitivity domains (e.g. HR, hospitals) while still usable for low‑stakes groups.

### 1.6 What Orgo is (and is not)

Orgo is:

* A **unified, schema‑driven case & task platform** that multiple orgs and domains plug into.
* A **routing + escalation + pattern‑detection engine** over signals and work.

Orgo is **not**:

* A generic CRM / ERP / accounting system.
* A stand‑alone kanban board toy.

---

## 2. Global invariants & enums (locked)

These enums and core concepts are **canonical** for Orgo v3. Other docs and code must reference them rather than introduce alternatives.

### 2.1 Environments

```text
ENVIRONMENT = { "dev", "staging", "prod", "offline" }
```

* `dev`      – local / developer environments.
* `staging`  – pre‑production staging.
* `prod`     – production.
* `offline`  – disconnected nodes that sync later.

Every config file must include:

```yaml
metadata:
  environment: "<dev|staging|prod|offline>"
  version: "3.x"
  last_updated: "YYYY-MM-DD"
```

### 2.2 Multi‑tenancy & identity invariants

* Every org has `organizations.id` → `organization_id` elsewhere.
* Every org may have **one active profile** (`organization_profiles`).
* Every Task/Case/Email/Notification/Log:

  * Either belongs to exactly one org (`organization_id` NOT NULL),
  * Or is a global default/config row (`organization_id` NULL).

User vs Person:

* **User** (`user_accounts`) = login account in an org.
* **Person** (`person_profiles`) = a human subject (student, employee, player, community member), optionally linked to a user.

### 2.3 Task lifecycle

Canonical DB enum: `task_status_enum`.

```text
TASK_STATUS = {
  "PENDING",
  "IN_PROGRESS",
  "ON_HOLD",
  "COMPLETED",
  "FAILED",
  "ESCALATED",
  "CANCELLED"
}
```

Semantics:

* `PENDING`     – created, not started.
* `IN_PROGRESS` – someone is actively working on it.
* `ON_HOLD`     – paused (waiting on dependency/decision).
* `COMPLETED`   – done successfully.
* `FAILED`      – attempted but unsuccessful; further action needed.
* `ESCALATED`   – escalated to higher authority/queue.
* `CANCELLED`   – explicitly stopped.

**Rules:**

* These are the **only** allowed values in DB, APIs, logs for Task status.
* State machine constraints and allowed transitions are specified in **Doc 5** and must be enforced everywhere.

### 2.4 Case lifecycle

Canonical DB enum: `cases.status`.

```text
CASE_STATUS = {
  "open",
  "in_progress",
  "resolved",
  "archived"
}
```

* `open`        – new Case, not yet being actively worked.
* `in_progress` – actively being handled (has active Tasks).
* `resolved`    – outcome reached and communicated.
* `archived`    – closed; kept for history/compliance.

These are the only allowed values for `cases.status`.

### 2.5 Priority & severity

```text
TASK_PRIORITY = { "LOW", "MEDIUM", "HIGH", "CRITICAL" }
TASK_SEVERITY = { "MINOR", "MODERATE", "MAJOR", "CRITICAL" }
```

* **Priority** – how fast we want to act (SLA / scheduling).
* **Severity** – how bad it is if we don’t (impact / risk).

All Task and Case severity fields MUST use `TASK_SEVERITY` (DB: `task_severity_enum`).

### 2.6 Visibility & privacy

Canonical DB enum: `visibility_enum`.

```text
VISIBILITY = {
  "PUBLIC",       # visible across the org (subject to RBAC)
  "INTERNAL",     # limited to org‑internal teams/roles
  "RESTRICTED",   # minimal set of users/roles
  "ANONYMISED"    # pseudonymised or fully anonymised content
}
```

Examples:

* Public safety broadcast → `PUBLIC`.
* HR or clinical report → often `RESTRICTED` or `ANONYMISED` depending on profile and policies.

Visibility interacts with exports and analytics per Doc 6 (e.g. only `PUBLIC`/`INTERNAL` rows can be raw-exported by default).

#### 2.6.1 Comment-level visibility (Task comments)

Task comments have their own per-comment visibility enum, stored in `task_comments.visibility`:

```text
COMMENT_VISIBILITY = {
  "internal_only",      # visible only to internal staff on the case/task
  "requester_visible",  # visible to the original requester plus internal staff
  "org_wide"            # visible to all authorized users in the organization
}
```

This is a **comment-level audience flag**, distinct from the global `VISIBILITY` enum used on Tasks and Cases. Implementations must not introduce additional values beyond these three without updating the schema and this document.

### 2.7 Log categories & levels

```text
LOG_CATEGORY = {
  "WORKFLOW",
  "TASK",
  "SYSTEM",
  "SECURITY",
  "EMAIL"
}

LOG_LEVEL = {
  "DEBUG",
  "INFO",
  "WARNING",
  "ERROR",
  "CRITICAL"
}
```

`WARNING` is the canonical log‑level value. Configuration loaders may accept `WARN` as a synonym and normalise it to `WARNING`, but `WARN` is not itself a first‑class enum value. Implementations must treat `DEBUG`, `INFO`, `WARNING`, `ERROR`, and `CRITICAL` as the complete `LOG_LEVEL` set.

Minimum fields per log entry:

```jsonc
{
  "timestamp": "2025-11-18T10:01:02Z",
  "level": "INFO",
  "category": "WORKFLOW",
  "message": "Task routed to maintenance queue",
  "identifier": "task_id:12345"
}
```

Logging and audit tables (`activity_logs`, `security_events`, `system_metric_snapshots`) store structured data aligned with these enums.

### 2.8 Notification channels & scope

```text
NOTIFICATION_CHANNEL = {
  "EMAIL",
  "SMS",
  "IN_APP",
  "WEBHOOK"
}
```

* `EMAIL` is mandatory; others are optional per deployment.
* DB `notifications.channel` stores lower‑case versions (`email`, `in_app`, `sms`, `webhook`).
* `PUSH` is not a distinct channel in Orgo v3; mobile push, if implemented, is modelled via `IN_APP` plus client‑side delivery.

Notification scope (metadata / workflow rules):

```text
NOTIFICATION_SCOPE = {
  "user",        # single user
  "team",        # owning team
  "department",  # functional group / department
  "org_wide"     # whole org
}
```

JSON/YAML store these as shown; UIs may map to friendlier labels.

### 2.9 Canonical label string format

Canonical label format (for `tasks.label`, `cases.label`):

```text
<label> = "<BASE>.<CATEGORY><SUBCATEGORY>.<HORIZONTAL_ROLE>"
```

* `BASE` – numeric vertical base (e.g. `1`, `11`, `100`, `1000`).
* `CATEGORY` – 1–9 classification (operational, strategic, compliance, etc.).
* `SUBCATEGORY` – 1–5 intent (request, update, decision, report, distribution).
* `HORIZONTAL_ROLE` – functional role (`Ops.Maintenance`, `HR.Recruitment`, `Finance.Audit`, etc.).

Broadcast bases:

* `10`, `100`, `1000` → informational broadcasts (non‑actionable unless workflow rules explicitly say otherwise).

Doc 8 carries the full label taxonomy and vertical/horizontal semantics; this document only locks the **string shape** and broadcast default behaviour.

### 2.10 Canonical Task field set (JSON contract)

This is the **minimum canonical Task representation** used in APIs and logs. DB tables may have additional columns, but these fields must always be present and aligned with Doc 1.

```jsonc
{
  "task_id": "uuid-v4-string",                 // PK (DB: tasks.id)
  "organization_id": "uuid-v4-string",         // tenant isolation
  "case_id": "uuid-v4-string | null",          // optional Case link

  "created_at": "ISO-8601 (UTC)",
  "updated_at": "ISO-8601 (UTC)",

  "type": "string",                            // domain type: "maintenance" | "hr_case" | "education_support" | "it_support" | "operations" | "generic" ...
  "category": "string",                        // "request" | "incident" | "update" | "report" | "distribution"
  "subtype": "string | null",                  // domain subtype ("plumbing", "harassment", ...)

  "title": "string",                           // short human label
  "description": "string",                     // free-text body

  "label": "string",                           // canonical label "<base>.<category><subcategory>.<horizontal_role>"

  "status": "PENDING",                         // TASK_STATUS (enum)
  "priority": "MEDIUM",                        // TASK_PRIORITY
  "severity": "MODERATE",                      // TASK_SEVERITY

  "visibility": "INTERNAL",                    // VISIBILITY
  "source": "email",                           // "email" | "api" | "manual" | "sync"

  "created_by_user_id": "uuid-v4-string | null",
  "requester_person_id": "uuid-v4-string | null",

  "owner_role_id": "uuid-v4-string | null",
  "owner_user_id": "uuid-v4-string | null",
  "assignee_role": "string | null",            // denormalised role label, for routing/UX

  "due_at": "ISO-8601 or null",                // deadline
  "reactivity_time": "ISO-8601 duration or null",   // SLA window ("PT2H")
  "reactivity_deadline_at": "ISO-8601 or null",     // resolved from created_at + reactivity_time
  "escalation_level": 0,                       // 0 = none, 1+ escalation depth
  "closed_at": "ISO-8601 or null",

  "metadata": { }                              // domain-specific payload; no duplication of core fields
}
```

Notes:

* `task_id` is the canonical external name; older docs using `id` must be interpreted as `task_id`.
* `status`, `priority`, `severity`, `visibility`, `source` MUST be from the enums defined above/Doc 1.
* Domain‑specific values (asset IDs, harassment categories, class codes, etc.) go under `metadata` or domain link tables (`maintenance_task_links`, `education_task_links`, etc.).

### 2.11 Canonical Case field skeleton

For Cases, Doc 1 defines the physical schema (`cases`); this doc only fixes the minimum JSON shape.

```jsonc
{
  "case_id": "uuid-v4-string",                // PK (DB: cases.id)
  "organization_id": "uuid-v4-string",

  "source_type": "email",                     // "email" | "api" | "manual" | "sync"
  "source_reference": "string | null",

  "label": "string",                          // canonical label
  "title": "string",
  "description": "string",

  "status": "open",                           // CASE_STATUS
  "severity": "major",                        // TASK_SEVERITY (JSON lower-case; maps to DB enum MAJOR)

  "reactivity_time": "ISO-8601 duration or null",

  "origin_vertical_level": 1000,
  "origin_role": "Ops.Maintenance",

  "tags": [ "safety", "wet_floor" ],
  "location": { },                            // structured, free-form
  "metadata": { },                            // includes profile, pattern_sensitivity, review_frequency, etc.

  "created_at": "ISO-8601 (UTC)",
  "updated_at": "ISO-8601 (UTC)"
}
```

JSON MAY use lower-case severity tokens (`"minor"`, `"moderate"`, `"major"`, `"critical"`); these must map 1:1 to the DB enum values `MINOR`, `MODERATE`, `MAJOR`, `CRITICAL`.

---

## 3. Configuration system (YAML‑based, environment‑aware)

Configuration is stored under `/config`, is **validated on startup**, and is composed from:

* Global defaults.
* Organization overrides.
* Environment selection (`dev` / `staging` / `prod` / `offline`).

### 3.1 Directory layout (illustrative)

```text
/config/
  database/
    database_connection.yaml
  email/
    email_config.yaml
  logging/
    logging_config.yaml
  workflows/
    global_workflow_rules.yaml
  insights/
    config.yaml
  profiles/
    organization_profiles.yaml
  organizations/
    default_organization_config.yaml
    <org-slug>.yaml
```

Modules (Core, Domain, Insights) may contribute their own subtrees, but all follow the same metadata & validation rules.

### 3.2 Common metadata & validation

Every YAML config file:

```yaml
metadata:
  config_name: "service_or_module_name"       # e.g. "email_config", "database_connection"
  version: "3.0"
  environment: "<dev|staging|prod|offline>"
  last_updated: "YYYY-MM-DD"
  owner: "team-or-responsible-role"
  organization_id: "default"                  # optional; "default" or specific org slug/id for org-scoped configs
```

Validation (hard rules):

* `metadata.environment` ∈ `ENVIRONMENT`.
* `metadata.version` matches `^3\.[0-9]+$` for Orgo v3 configs.
* `metadata.last_updated` is a valid `YYYY-MM-DD` date.
* `metadata.config_name` is a non-empty string used as a stable identifier for this config.
* If present, `metadata.organization_id` must either be `"default"` or a valid organization identifier known to the deployment.

On failure:

* Emit `LOG_CATEGORY = SYSTEM`, `LOG_LEVEL = ERROR`.
* Either refuse to start or fall back to safe defaults, depending on module.

### 3.3 Database config

`/config/database/database_connection.yaml` (Core Services spec covers the detailed keys).

Invariants:

* Only one of `postgres.enabled` / `sqlite.enabled` may be `true`.
* For Postgres, connection pool bounds `min_connections <= max_connections`.
* For SQLite, `file_path` must be writable in the environment.

### 3.4 Email config

`/config/email/email_config.yaml` defines SMTP/IMAP endpoints, timeouts, and attachment limits.

Hard checks:

* At least one of SMTP/IMAP configured.
* `limits.max_email_size_mb > 0`.
* Attachment lists are non‑empty and constrained to allowed types.

### 3.5 Logging config

`/config/logging/logging_config.yaml` binds log categories to sinks, levels, rotation and retention.

* All categories in config must map to `LOG_CATEGORY`.
* Levels must be from `LOG_LEVEL`.
* Retention and rotation policies must be consistent with org profiles and compliance requirements.

---

## 4. Core Services – contracts & checklists

Core Services are the headless backbone: email gateway, task handler, workflow engine, notifications, persistence, logging, validation/security. Full details in Doc 5; this section defines cross‑cutting expectations.

### 4.1 Workflow Engine

Responsibilities:

* Load and validate workflow rules (`/config/workflows/*.yaml`).
* Evaluate rules on events (email, task updates, timers).
* Emit a deterministic action list (CREATE_TASK, ROUTE, ESCALATE, NOTIFY, etc.).
* Log steps under `WORKFLOW` / `TASK`.

Checklist:

* [ ] Rules validated at startup (required keys, enum usage).
* [ ] Uses `Task.type` (domain) vs `Task.category` (request/incident/...) correctly.
* [ ] Never hardcodes domain‑specific branches; domain behaviour is via config/metadata.
* [ ] Emits structured logs with identifiers for traceability.

### 4.2 Email Gateway

Responsibilities:

* Poll mailboxes; ingest, parse, and normalise emails into `email_messages`.
* Validate size, attachments, minimal fields.
* Link emails to Tasks/Cases via workflow + domain rules.
* Send outbound email as part of notifications.

Checklist:

* [ ] Connection validated on startup.
* [ ] Transient failures retried with backoff.
* [ ] Logs redacted (no raw bodies, minimal headers).
* [ ] Enforces configured limits and attachment policies.

### 4.3 Task Handler

Responsibilities:

* Implement the canonical Task lifecycle using `TASK_STATUS`.
* Enforce allowed state transitions and escalation rules.
* Expose create/update/assign/escalate APIs used by domain modules and interfaces.

Checklist:

* [ ] `create_task` enforces required fields and enums.
* [ ] `update_task_status` validates transitions.
* [ ] `escalate_task` increments `escalation_level`, sets `ESCALATED`, and records events.
* [ ] Uses `organization_id` + visibility + RBAC for every Task read/write.

### 4.4 Notification Service

Responsibilities:

* Route events (CREATED, ASSIGNED, ESCALATED, COMPLETED) into channel‑specific notifications.
* Respect `NOTIFICATION_SCOPE` and Profiles (`notification_scope` in profile YAML).

Checklist:

* [ ] Supports at least `EMAIL` + optional `IN_APP`.
* [ ] Chooses recipients based on owner/assignee roles + scope.
* [ ] Logs all attempts and failures with structured identifiers.
* [ ] Applies PII masking rules for certain channels (e.g. exports, webhooks).

### 4.5 Persistence & offline sync

Responsibilities:

* Abstract DB connections (Postgres for online, SQLite for offline).
* Provide safe CRUD helpers for Tasks, Cases, Emails, Logs, etc.
* Coordinate offline sync (`offline_nodes`, `sync_sessions`, `sync_conflicts`).

Checklist:

* [ ] All queries parameterised.
* [ ] Multi‑tenant filters enforced (`organization_id`).
* [ ] Sync conflicts recorded and resolvable.
* [ ] Analytics readers treat operational tables as read‑only.

### 4.6 Logging & security hooks

Responsibilities:

* Provide unified `log_event` entry point.
* Integrate with security policies for sensitive operations (logins, exports, config changes).

Checklist:

* [ ] All security‑relevant operations go to `security_events`.
* [ ] Task/Case status changes are logged in `task_events` + `activity_logs`.
* [ ] Export requests log who, what, when, and result.

---

## 5. Domain Modules – position & invariants

Domain modules are thin adapters over the core backbone. Canonical spec in **Doc 3**; this section fixes cross‑module rules.

### 5.1 Directory & naming

* Root: `domain_modules/<domain>/`.

* Must contain:

  * `<domain>_module.yaml` – config (categories, subtypes, email patterns, routing hints).
  * `<domain>_handler.py` – code hooks for create/update and domain views.

* `<domain>` string must match `Task.type`.

### 5.2 Domain config rules

In `<domain>_module.yaml`:

* `allowed_categories` is a subset of the global enum `{request, incident, update, report, distribution}`.
* Domain subtypes live in `allowed_subtypes` and are stored under `Task.subtype` / `metadata["domain_subtype"]`.
* `email_patterns` define how inbound emails are recognised as belonging to the domain.
* Defaults for `visibility`, `category`, routing are allowed, but domain configs **must not** redefine global enums.

### 5.3 Handler hooks (behaviour)

Handlers implement, at minimum:

* `on_task_create(ctx, payload)` – validate and enrich before Task persists.
* `on_task_created(ctx, task_id)` – fire notifications, side‑effects.
* `on_task_update(ctx, payload)` – validate before updates.
* `on_task_updated(ctx, task_id)` – follow‑up side‑effects.
* `get_domain_fields(ctx, task_id)` – domain‑specific view of metadata.

Constraints:

* Must not write directly to DB; always go through the Task Handler.
* Must use canonical enums for status, priority, severity, visibility.
* Must not weaken visibility or bypass guardrails.

---

## 6. Organization profiles & behavioural tuning

Profiles describe **how intense/urgent/private** a deployment is. Physical storage is in a YAML file (`profiles:`) and in `organization_profiles`.

### 6.1 Profile schema (summary)

Per profile:

* `reactivity_seconds`, `max_escalation_seconds`.
* `transparency_level` (full/balanced/restricted/private).
* `escalation_granularity` (relaxed/moderate/detailed/aggressive).
* `review_frequency` (real_time/daily/weekly/monthly/quarterly/yearly/ad_hoc).
* `notification_scope` (user/team/department/org_wide). Older configs may still use `individual` (→ `user`) and `small_team` (→ `team`); loaders may treat these as aliases, but the canonical tokens are `user`, `team`, `department`, `org_wide`.
* `pattern_sensitivity`, `pattern_window_days`, `pattern_min_events`.
* `severity_threshold` + `severity_policy` (immediate escalation per severity).
* `logging_level` + `log_retention_days`.
* `automation_level` (manual/low/medium/high/full).
* `default_task_metadata` (visibility, default_priority, default_reactivity_seconds).
* `cyclic_overview` settings (enabled, schedules, threshold_triggers).

Profiles are **templates**; Orgo ties them to orgs via `organization_profiles.profile_code`.

### 6.2 Example profile mapping

Examples (keys from profiles YAML): `friend_group`, `hospital`, `advocacy_group`, `retail_chain`, `military_organization`, `environmental_group`, `artist_collective`.

Core Services & Insights:

* Read profile to derive defaults for Task priority, severity, visibility, reactivity_time.
* Adjust escalation policies and notification scopes.
* Tune logging/audit retention and pattern windows.

---

## 7. Insights & cyclic overview integration

Insights and the cyclic overview transform the operational DB into **pattern sensing**. Normative definitions in Docs 6 & 8; this section only fixes integration points.

### 7.1 Analytics schema & ETL

* Star schema in `insights.*` (dimensions: dates, organizations, tasks, cases, persons, groups; facts: tasks, cases, wellbeing check‑ins).
* ETL jobs (Airflow DAGs) populate `fact_tasks`, `fact_cases`, `fact_wellbeing_checkins`, etc., under controlled retention windows and backup policies.

### 7.2 Patterns as work

Cyclic overview logic:

* Weekly/monthly/yearly jobs detect patterns (incident frequency, cross‑department trends, high‑risk indicators).
* Crossing a threshold **must** create new Cases (often labelled as audits or systemic reviews), not just charts.

This doc locks:

* That patterns become **Cases and Tasks**, not “just dashboards”.
* That pattern detection respects profiles (pattern_sensitivity, pattern_window_days) and visibility.

---

## 8. Guardrails – visibility, audit, compliance

Guardrails apply across the stack:

* Visibility enums (`VISIBILITY`) control who can see raw content and exports.
* Logging/audit tables are canonical (`activity_logs`, `security_events`, `system_metric_snapshots`).
* Security events track sensitive operations (failed logins, permission escalation, exports, config changes).
* Exports in Insights enforce rows‑per‑export limits, PII masking, and allowed visibilities.

Invariants:

* Sensitive domains (HR cases, clinical incidents) must use `RESTRICTED` or `ANONYMISED` visibility and/or specialised domain tables (`hr_cases`, `wellbeing_checkins`, etc.).
* All Task/Case status changes and escalations must be logged and traceable back to actors (user/role/profile) and origin (UI/API/email/system).

---

## 9. Testing & operational checklists (cross‑cutting)

Minimum testing structure:

```text
/tests/
  core_services/
  domain_modules/
  interfaces/
  integration/
```

Expectations:

* Core Services: ~80%+ coverage for critical functions.
* Config loaders: ~90%+ coverage (success and failure paths).
* Integration tests for end‑to‑end flows (email → Task → escalation → notification).
* Smoke tests per environment for configuration validity.

Operational checklists:

* Each service must start with valid config or fail fast.
* Each domain module must pass Doc 3 compliance checklist.
* Each environment must have working logging, notifications and health checks.

---

## 10. Summary – what this document locks

This document **locks** the following for Orgo v3:

* **Multi‑tenant invariants** around `organization_id`, Users vs Persons, and Roles.

* **Core enums**:

  * `ENVIRONMENT`
  * `TASK_STATUS`
  * `CASE_STATUS`
  * `TASK_PRIORITY`
  * `TASK_SEVERITY`
  * `VISIBILITY`
  * `LOG_CATEGORY`
  * `LOG_LEVEL`
  * `NOTIFICATION_CHANNEL`
  * `NOTIFICATION_SCOPE`

* **Canonical label format**: `<base>.<category><subcategory>.<horizontal_role>` and broadcast bases (`10/100/1000` informational by default).

* **Canonical Task field set** and minimal **Case field skeleton**.

* **Config expectations** (metadata, validation, per‑environment decomposition).

* **Core Services contracts & checklists** (workflow, email, task handler, notifications, persistence, logging).

* **Domain module invariants** (thin adapters, no custom lifecycles).

* **Profile + Insights integration**: behaviour tuning plus pattern‑detection feeding back as work.

* **Guardrails** for visibility, logging, audit, and exports.

All other docs in Orgo v3 (Docs 1, 3, 4, 5, 6, 8, etc.) must **reference and remain aligned to these definitions**, not redefine them. 

===== END 2-orgo-documentation-index.md (#0002) =====

===== BEGIN 3-orgo-full-stack-technical-spec.md (#0003) =====
﻿<!-- INDEX: Doc 3 – Domain Modules (Orgo v3) -->
Index

Canonical Concepts (shared with other docs)
0.1 Global Task Model (summary)
0.2 Cases and labels (context)
0.3 Domain Modules vs DomainTasks

Domain Module directory layout

Domain Module config spec (<domain>_module.yaml)
2.1 Top‑level structure
2.2 Category vs type vs subtype alignment
2.3 Subtype semantics (allowed_subtypes)
2.4 Email mapping (email_patterns)
2.5 Labels & broadcast semantics

DomainTask model and mapping to Task
3.1 Shape of DomainTask
3.2 Construction rules

Domain handler interface (<domain>_handler.py)
4.1 Required functions (on_task_create, on_task_created, on_task_update, on_task_updated, get_domain_fields)
4.2 Optional functions (suggest_category_and_subtype, get_domain_filters)

Domain Module lifecycle
5.1 Module discovery
5.2 Email → DomainTask creation flow
5.3 API / UI listing flow
5.4 Status, visibility, profiles
5.5 Case linkage (optional)

Worked example – Maintenance Module
6.1 Config example (maintenance_module.yaml)
6.2 Handler outline (maintenance_handler.py)

Worked example – HR Module
7.1 Config example (hr_case_module.yaml)
7.2 Handler sketch

Checklist for Domain Modules (Doc 3 compliance)

---

## 3/8 – Domain Modules (Orgo v3)

**Scope**

This document defines how each **domain module** (maintenance, HR, education, etc.) is structured, configured, and integrated with the **central task handler** and the **multi‑tenant backbone**.

Domain modules are **thin adapters** over the core Orgo platform:

* They do **not** own a task lifecycle.
* They do **not** maintain their own task tables.
* They **wrap** the canonical **Task** (and optionally **Case**) model with domain‑specific configuration, validation, and field mapping.
* They use the shared **label system** and **broadcast semantics** from Doc 8 for routing and visibility.

Routing, lifecycle, escalation, and pattern detection always flow through:

* Core task handler – Doc 5 (`task_handler` service).
* Workflow engine – Doc 5 (`workflow_engine` service).
* Canonical Task/Case models and enums – Docs 1–2 and Doc 8.

This doc **supersedes** earlier informal notes on domain modules (e.g. Doc 2 §4 directory sketch). Where there is conflict, **Doc 3 wins** for module layout and handler contracts.

---

## 0. Canonical Concepts (Shared with Other Docs)

Domain modules are not allowed to redefine global concepts. They must re‑use:

* The **canonical Task model** (DB + JSON).
* The **canonical Case model** (where needed).
* Global enums for **status, priority, severity, visibility**.
* The **labeling system** (vertical/horizontal axes, broadcast bases).

### 0.1 Global Task Model (Summary)

Canonical Task fields (logical view) are defined in Doc 1 §3.1 and Doc 2 §1.7.

Key fields (simplified):

* `task_id`: UUID (DB: `tasks.id`)
* `organization_id`: UUID – tenant / org isolation key
* `case_id`: UUID | null – optional link to a `Case`
* `type`: string – domain identifier, e.g. `"maintenance"`, `"hr_case"`, `"education_support"`, `"it_support"`, `"operations"`, `"generic"`
* `category`: string – global enum: `"request" | "incident" | "update" | "report" | "distribution"`
* `subtype`: string | null – domain‑specific label (e.g. `"plumbing"`, `"harassment"`, `"attendance"`)
* `label`: string – canonical information label `<base>.<category><subcategory>.<horizontal_role>`
* `status`: `TASK_STATUS` enum – `PENDING | IN_PROGRESS | ON_HOLD | COMPLETED | FAILED | ESCALATED | CANCELLED`
* `priority`: `TASK_PRIORITY` enum – `LOW | MEDIUM | HIGH | CRITICAL`
* `severity`: `TASK_SEVERITY` enum – `MINOR | MODERATE | MAJOR | CRITICAL`
* `visibility`: `VISIBILITY` enum – `PUBLIC | INTERNAL | RESTRICTED | ANONYMISED`
* `source`: `TASK_SOURCE` enum – `email | api | manual | sync`
* `due_at`, `reactivity_time`, `reactivity_deadline_at`, `escalation_level`, `closed_at`
* `owner_role_id`, `owner_user_id` – normalized FKs for the current owning role/user
* `assignee_role` – denormalised routing string (e.g. `"Ops.Maintenance"`); assignment history lives in `task_assignments`
* `metadata`: JSONB – domain‑specific, must **not duplicate** core fields

**Important alignment points for domain modules:**

* `organization_id` is the canonical multi‑tenant key (not `tenant_id`).
* `subtype` is a first‑class column in `tasks.subtype` and must hold the **domain subtype** used in configs (not just `metadata["domain_subtype"]`).
* `visibility` must be one of `PUBLIC/INTERNAL/RESTRICTED/ANONYMISED` (DB) and may be lower‑case equivalents in JSON/YAML.
* `source`, `reactivity_deadline_at` and `closed_at` are canonical fields set by core services; domain modules treat them as read‑only and must not attempt to re‑implement SLA logic independently of profiles and workflows.

### 0.2 Cases and Labels (Context Only)

* **Case** is a long‑lived container that groups Tasks, patterns, and context. Cases use the same label and severity model as Tasks.
* `cases.label` and `tasks.label` hold the **canonical information label** `<BASE>.<CATEGORY><SUBCATEGORY>.<HORIZONTAL_ROLE>`.
* Classification tags (e.g. `self_harm_risk`, `equipment_failure`) are separate – `label_definitions` + `entity_labels`.

Domain modules may **read** and **suggest** labels and tags, but they **do not change** the underlying label system; this is defined centrally in Doc 8.

### 0.3 Domain Modules vs DomainTasks

* A **Domain Module** is a bundle of:

  * One YAML config file.
  * One handler module (`<domain>_handler.*`) with a fixed function interface.
  * Optional templates and helpers.

* A **DomainTask** is a **projection** of a canonical `Task` for a given domain:

  * DomainTask has no table.
  * It is constructed from `Task` (+ assignments + classification labels).
  * It may expose computed/curated fields for UI.
  * All writes flow back to the canonical `Task` model via the core task handler.

---

## 1. Domain Module Directory Layout

All domain modules live under a single root:

```text
domain_modules/
  maintenance/
    maintenance_module.yaml
    maintenance_handler.py
    templates/
      ...
  hr_case/
    hr_case_module.yaml
    hr_case_handler.py
    templates/
      ...
  education/
    education_module.yaml
    education_handler.py
    templates/
      ...
```

Constraints:

* Directory name = **domain name** and must match `Task.type`.
  Example: directory `domain_modules/maintenance/` ↔ `Task.type = "maintenance"`.

* Each domain has **exactly one** main config and one main handler:

  * `<domain>_module.yaml`
  * `<domain>_handler.py`

* Optional assets (`templates/`, additional YAML files) are referenced **via the main config** (no extra implicit conventions).

---

## 2. Domain Module Config Spec (`<domain>_module.yaml`)

Each domain module has one canonical config loaded by `core_services/config_loader`. Config values must respect enums and conventions from Docs 1–2 and Doc 5.

### 2.1 Top‑Level Structure

Minimum canonical structure:

```yaml
domain: "maintenance"            # must match directory name and Task.type
version: "3.0.0"                 # semantic version of the module
enabled: true                    # if false, module is ignored

allowed_categories:              # global Task.category values
  - "request"
  - "incident"
default_category: "request"      # must be in allowed_categories

allowed_subtypes:                # domain-specific Task.subtype values
  - "ticket"
  - "inspection"

default_visibility: "internal"   # maps to VISIBILITY.INTERNAL
allowed_visibility:
  - "internal"
  - "restricted"                 # subset of {public, internal, restricted, anonymised}

email_patterns:                  # how emails are mapped (see 2.4)
  from_addresses:
    - "maintenance@tenant.example"
  to_addresses:
    - "maintenance@tenant.example"
  subject_keywords:
    - "[MAINT]"
    - "maintenance"
    - "repair"
  body_keywords:
    - "leak"
    - "broken"
    - "malfunction"

routing_rules:                   # domain-specific routing hints (passed to workflows)
  default_assignee_group: "maintenance_team"
  escalation_group: "maintenance_leads"
```

Validation invariants:

* `domain` = directory name and will be used as `Task.type`.
* `allowed_categories` ⊆ global enum `{request, incident, update, report, distribution}`.
* `default_category ∈ allowed_categories`.
* `default_visibility ∈ allowed_visibility ⊆ {public, internal, restricted, anonymised}`.
* Visibility values are in **JSON/Config form** (lowercase), but must map to DB enum `VISIBILITY`.

### 2.2 Category vs Type vs Subtype (Alignment)

To eliminate ambiguity:

* `Task.type` = **domain identifier** (e.g. `"maintenance"`, `"hr_case"`, `"education_support"`).
* `Task.category` = **global category** (`"request"`, `"incident"`, `"update"`, `"report"`, `"distribution"`).
* `Task.subtype` = **domain‑specific label** (e.g. `"ticket"`, `"inspection"`, `"harassment"`, `"attendance"`).

Therefore:

* The old config key `allowed_types` is **removed** in v3.
* Domain modules must use:

  * `allowed_categories`: allowed values for `Task.category`.
  * `allowed_subtypes`: allowed values for `Task.subtype`.

Mapping to DB and JSON:

* `category` → `tasks.category` (enum) and Task JSON `category`.
* `subtype` → `tasks.subtype` (TEXT) and Task JSON `subtype`.
* Domain‑specific extra flags stay in `tasks.metadata`.

Example (Maintenance):

```yaml
domain: "maintenance"
allowed_categories:
  - "request"
  - "incident"
default_category: "request"
allowed_subtypes:
  - "ticket"
  - "inspection"
```

A “maintenance ticket” with category `request`:

* `task.type = "maintenance"`
* `task.category = "request"`
* `task.subtype = "ticket"`

Domain modules must **not** redefine category semantics via subtypes.

### 2.3 Subtype Semantics (`allowed_subtypes`)

`allowed_subtypes` is purely **domain‑local**:

* Validation:

  * Loader ensures uniqueness and that configured subtypes are strings.
  * No global enum is enforced; they live in `tasks.subtype`.

* Storage:

  * On creation, if a subtype is chosen it must be:

    * `payload.subtype ∈ allowed_subtypes` (or `None`).

* Usage:

  * Filters in domain UIs (e.g. “show only `inspection`”).
  * Domain routing/handling logic in `<domain>_handler`.
  * Domain‑scoped reports (via Insights star schema).

### 2.4 Email Mapping (`email_patterns`)

`email_patterns` describes how incoming email is matched to a domain:

```yaml
email_patterns:
  from_addresses:
    - "maintenance@tenant.example"
  to_addresses:
    - "maintenance@tenant.example"
  cc_addresses:
    - "maintenance-cc@tenant.example"
  subject_keywords:
    - "[MAINT]"
    - "maintenance"
    - "repair"
  body_keywords:
    - "leak"
    - "broken"
    - "malfunction"
```

Resolution (high‑level):

1. `to`/`cc` matches domain addresses → direct match.
2. Else if subject contains any `subject_keywords` → probable match.
3. Else if body contains `body_keywords` → fallback match.
4. If multiple domains match, the core handler resolves based on workflow rules and priorities (Doc 5 + Doc 2).

The mapping logic lives in the **Email Gateway + Workflow Engine**; domain modules only supply configuration.

### 2.5 Labels & Broadcast Semantics

Domain modules must respect the global **label system** and **broadcast bases** from Doc 8.

Key points:

* `Task.label` and `Case.label` hold the canonical label like `100.94.Operations.Safety`.

* Vertical base (`10`, `100`, `1000`) indicates broadcast scope:

  * `10.x`: executive broadcast.
  * `100.x`: department‑head broadcast.
  * `1000.x`: staff‑level broadcast.

* Broadcast labels are **non‑actionable by default**:

  * They must **not** automatically create Tasks.
  * They exist for information and alignment.

Domain modules:

* May define **label‑aware rules** (typically in workflow configs, not in the module YAML) such as:

  ```yaml
  - match_label_base: 1000
    category: 9
    subcategory: 5
    auto_create_tasks: false
  ```

* Must treat broadcast‑labeled items as informational unless an explicit workflow rule enables `auto_create_tasks: true` and that behaviour is documented for the domain.

This constraint is normative: domain modules **must not** override global broadcast semantics in ad‑hoc code.

---

## 3. DomainTask Model and Mapping to Task

`DomainTask` is a view‑layer construct used by domain APIs and UIs.

### 3.1 Shape of DomainTask

Python‑style sketch:

```python
@dataclass
class DomainTask:
    task_id: UUID
    organization_id: UUID

    domain: str            # == Task.type
    category: str          # == Task.category (global)
    subtype: str | None    # == Task.subtype (domain-local)

    label: str             # == Task.label (canonical label code)

    status: str            # == Task.status
    priority: str          # == Task.priority  (TASK_PRIORITY)
    severity: str          # == Task.severity  (TASK_SEVERITY)
    visibility: str        # == Task.visibility

    title: str             # == Task.title
    description: str       # == Task.description

    case_id: UUID | None   # == Task.case_id

    created_at: datetime
    updated_at: datetime

    assignee_user_ids: list[UUID]   # from TaskAssignment history + current owner
    assignee_roles: list[str]       # e.g. ["Ops.Maintenance"]

    classification_labels: list[str]  # codes from label_definitions/entity_labels
    metadata: dict[str, Any]          # curated subset of Task.metadata for this domain
```

Constraints:

* `domain == Task.type`
* `category == Task.category`
* `subtype == Task.subtype`
* `label == Task.label`
* `status == Task.status` (global enum)
* `priority == Task.priority` (global enum)
* `severity == Task.severity` (global enum)
* `visibility == Task.visibility` (global enum)

DomainTask is **read‑only** with respect to the DB; updates must go through the core task handler APIs.

### 3.2 Construction Rules

Given a `Task` row (plus assignments and labels):

1. `organization_id = task.organization_id`
2. `domain = task.type`
3. `category = task.category`
4. `subtype = task.subtype`
5. `label = task.label`
6. `status = task.status`
7. `priority = task.priority`
8. `severity = task.severity`
9. `visibility = task.visibility`
10. `title = task.title`
11. `description = task.description`
12. `case_id = task.case_id`
13. `assignee_user_ids` and `assignee_roles` are derived from `task_assignments` (primary and secondary assignments), plus the current `owner_role_id` / `owner_user_id` and `assignee_role` fields on the Task.
14. `classification_labels` from `entity_labels` for that task.
15. `metadata` = curated view returned by `get_domain_fields` (handler).

Domain modules **never** talk directly to the DB; they work through the domain API and core services defined in Doc 5.

---

## 4. Domain Handler Interface (`<domain>_handler.py`)

Each domain module exports a handler implementing the following interface. The core task handler calls these hooks at specific points in the Task lifecycle.

### 4.1 Required Functions

```python
# <domain>_handler.py

from core_services.domain_api import DomainContext, DomainTaskInput, DomainTaskUpdate

def on_task_create(ctx: DomainContext, payload: DomainTaskInput) -> DomainTaskInput:
    """
    Called before a new Task is persisted for this domain.
    Responsibilities:
      - Enforce Task.type (domain).
      - Validate/normalize category and subtype.
      - Apply default visibility and metadata defaults.
    Must not write to the DB directly.
    Returns the payload that the core task handler will persist.
    """

def on_task_created(ctx: DomainContext, domain_task_id: str) -> None:
    """
    Called after the Task has been created and committed.
    Used for domain-specific notifications, logging, or webhooks.
    """

def on_task_update(ctx: DomainContext, payload: DomainTaskUpdate) -> DomainTaskUpdate:
    """
    Called before Task updates are persisted.
    Can enforce domain rules on category/subtype/visibility/metadata.
    Returns the updated payload.
    """

def on_task_updated(ctx: DomainContext, domain_task_id: str) -> None:
    """
    Called after updates are committed.
    Used for follow-up actions (e.g. notify on ESCALATED or COMPLETED).
    """

def get_domain_fields(ctx: DomainContext, task_id: str) -> dict:
    """
    Returns a domain-centric view of Task.metadata (plus some core fields)
    for UI/API use, e.g. location, asset_id, person references.
    """
```

`DomainContext` provides:

* `organization_id`
* Domain config (parsed `<domain>_module.yaml`)
* Repository/Service interfaces for Tasks, Cases, and labels
* Logger, clock, and profile information (Org’s behaviour profile for reactivity, transparency, etc.).

The central `task_handler`:

* Controls DB transactions.
* Calls these hooks inside transactions where appropriate.
* Enforces global invariants (enums, visibility rules, label semantics).

### 4.2 Optional Functions

Standard optional functions:

```python
def suggest_category_and_subtype(ctx: DomainContext, email_payload: dict) -> tuple[str, str | None]:
    """
    Given a parsed email, suggest (category, subtype).
    - category must be in config.allowed_categories
    - subtype must be in config.allowed_subtypes or None
    Used by the email gateway + workflow engine.
    """

def get_domain_filters(ctx: DomainContext) -> dict:
    """
    Returns domain-specific filter metadata for UI:
      - available subtypes
      - common labels or classification tags
      - suggested saved searches
    """
```

---

## 5. Domain Module Lifecycle

This section describes how domain modules are discovered and used across the stack.

### 5.1 Module Discovery

On startup, `config_loader`:

1. Scans `domain_modules/`.

2. For each directory containing `<domain>_module.yaml` and `<domain>_handler.py`:

   * Loads and validates YAML (using global config validation).
   * Imports the handler module.
   * Registers the module in an in‑memory `DomainRegistry`.

3. If `enabled: false`, the module is skipped.

### 5.2 Email → DomainTask Creation Flow

1. Email Gateway ingests email → `email_messages` row is created (Doc 1).

2. Workflow engine evaluates rules, including domain `email_patterns`.

3. If a domain matches:

   * Core builds a `DomainTaskInput`:

     * `type = <domain>`
     * `category = default_category` (override via `suggest_category_and_subtype`)
     * `subtype` from suggestion if valid.
     * `visibility` initially unset.
     * `metadata` including email linkage.

4. Core calls `on_task_create(domain_handler, ctx, payload)`.

5. Central `task_handler` persists the new `Task` and links it to the email/thread and, if configured, to a `Case`.

6. After commit, core calls `on_task_created`.

### 5.3 API / UI Listing Flow

Example endpoint: `GET /domain/<domain>/tasks`

1. API validates `<domain>` exists in `DomainRegistry`.

2. Queries `tasks` with:

   * `tasks.type = <domain>`
   * `tasks.organization_id = <current org>`
   * Visibility filters based on `VISIBILITY` and RBAC.

3. For each Task:

   * Builds a `DomainTask` view.
   * Augments with `get_domain_fields`.

4. Frontend filters by:

   * `category` (global),
   * `subtype` (domain),
   * `status`, `priority`, `severity`,
   * `label` (canonical) and classification tags,
   * assignee, date ranges, org profile‑driven “hot” filters.

### 5.4 Status, Visibility, Profiles

* Status transitions:

  * Must follow the global Task state machine (Doc 8 §8.5.2).
  * Domain modules may **restrict** transitions but cannot introduce new states.

* Visibility:

  * Domain handler may set a default `visibility` within the allowed subset.
  * Global rules (e.g. HR confidentiality, org profile transparency) are enforced by core services.

* Profiles:

  * Reactivity, escalation timing, logging depth, and pattern sensitivity are determined primarily by the org’s **profile** (Doc 7/Profile configs) and global parameters (Doc 2 + Doc 6). Domain modules provide hints (e.g. “HR incidents are usually `high` severity”), but do not hard‑code SLA logic.

### 5.5 Case Linkage (Optional)

Some domains (especially HR and compliance) treat Cases as primary:

* HR module may create or attach to an `HrCase` (Doc 1 Module 11) when certain subtypes appear (e.g. `harassment`).
* Domain handler itself does **not** write to `hr_cases` or `cases` directly; it triggers workflows that create/link Cases using core services.

General rule:

* **Tasks first** – domain modules always produce Tasks.
* **Cases via workflows** – Case creation/linkage is orchestrated by workflows and core services, using domain metadata and labels.

---

## 6. Worked Example – Maintenance Module

### 6.1 Config (`domain_modules/maintenance/maintenance_module.yaml`)

```yaml
domain: "maintenance"
version: "3.0.0"
enabled: true

allowed_categories:
  - "request"
  - "incident"
default_category: "request"

allowed_subtypes:
  - "ticket"
  - "inspection"

default_visibility: "internal"
allowed_visibility:
  - "internal"
  - "restricted"

email_patterns:
  from_addresses:
    - "maintenance@tenant.example"
  to_addresses:
    - "maintenance@tenant.example"
  subject_keywords:
    - "[MAINT]"
    - "maintenance"
    - "repair"
  body_keywords:
    - "leak"
    - "broken"
    - "malfunction"

routing_rules:
  default_assignee_group: "maintenance_team"
  escalation_group: "maintenance_leads"
```

Behaviour:

* All Maintenance tasks have:

  * `Task.type = "maintenance"`.
  * `Task.category ∈ {"request","incident"}`.
  * `Task.subtype ∈ {"ticket","inspection"} or null`.

* Defaults:

  * If no category → `request`.
  * If subtype missing or invalid → normalized to `"ticket"` or left `null` per policy.
  * Visibility defaults to `"internal"` (INTERNAL), may be raised to `"restricted"` by rules.

### 6.2 Handler Outline (`maintenance_handler.py`)

```python
from core_services.domain_api import DomainContext, DomainTaskInput, DomainTaskUpdate

ALLOWED_CATEGORIES = {"request", "incident"}
ALLOWED_SUBTYPES = {"ticket", "inspection"}

def on_task_create(ctx: DomainContext, payload: DomainTaskInput) -> DomainTaskInput:
    # Enforce domain
    payload.type = "maintenance"

    # Category normalization
    if payload.category not in ALLOWED_CATEGORIES:
        payload.category = ctx.config.default_category  # "request"

    # Subtype normalization
    if payload.subtype is not None and payload.subtype not in ALLOWED_SUBTYPES:
        payload.subtype = "ticket"

    # Default visibility
    if payload.visibility is None:
        payload.visibility = ctx.config.default_visibility  # "internal"

    return payload

def on_task_created(ctx: DomainContext, domain_task_id: str) -> None:
    # Notify maintenance_team defined in routing_rules
    ...

def on_task_update(ctx: DomainContext, payload: DomainTaskUpdate) -> DomainTaskUpdate:
    # Prevent illegal category changes
    if payload.category is not None and payload.category not in ALLOWED_CATEGORIES:
        raise ValueError("Invalid category for maintenance domain")
    # Subtype change validation
    if payload.subtype is not None and payload.subtype not in ALLOWED_SUBTYPES:
        raise ValueError("Invalid subtype for maintenance domain")
    return payload

def on_task_updated(ctx: DomainContext, domain_task_id: str) -> None:
    # Example: notify escalation_group on ESCALATED status
    ...

def get_domain_fields(ctx: DomainContext, task_id: str) -> dict:
    task = ctx.tasks_repo.get(task_id)
    return {
        "subtype": task.subtype,
        "location": task.metadata.get("location"),
        "asset_id": task.metadata.get("asset_id"),
    }
```

---

## 7. Worked Example – HR Module (Outline)

### 7.1 Config (`domain_modules/hr_case/hr_case_module.yaml`)

```yaml
domain: "hr_case"
version: "3.0.0"
enabled: true

allowed_categories:
  - "request"
  - "update"
  - "report"
default_category: "request"

allowed_subtypes:
  - "onboarding"
  - "offboarding"
  - "harassment"
  - "policy_question"

default_visibility: "restricted"
allowed_visibility:
  - "restricted"
  - "anonymised"

email_patterns:
  to_addresses:
    - "hr@tenant.example"
  subject_keywords:
    - "onboarding"
    - "offboarding"
    - "harassment"
    - "benefits"

routing_rules:
  default_assignee_group: "hr_officers"
  escalation_group: "hr_leadership"
```

Behaviour:

* `Task.type` for HR module = `"hr_case"`.
* Only `request`, `update`, `report` categories allowed.
* Subtypes: `"onboarding"`, `"offboarding"`, `"harassment"`, `"policy_question"`.
* Default visibility: `"restricted"` (RESTRICTED). Harassment‑related items may be auto‑upgraded to `"anonymised"` via handler logic and/or profiles.

### 7.2 Handler Sketch

```python
def on_task_create(ctx: DomainContext, payload: DomainTaskInput) -> DomainTaskInput:
    payload.type = "hr_case"

    if payload.category not in ctx.config.allowed_categories:
        payload.category = ctx.config.default_category  # "request"

    if payload.subtype not in ctx.config.allowed_subtypes:
        payload.subtype = "policy_question"

    # Harassment → anonymised visibility
    if payload.subtype == "harassment":
        payload.visibility = "anonymised"
    elif payload.visibility is None:
        payload.visibility = ctx.config.default_visibility  # "restricted"

    return payload

def get_domain_fields(ctx: DomainContext, task_id: str) -> dict:
    task = ctx.tasks_repo.get(task_id)
    return {
        "subtype": task.subtype,
        "employee_id": task.metadata.get("employee_id"),
        "reported_by_person_id": task.metadata.get("reported_by_person_id"),
        "target_person_id": task.metadata.get("target_person_id"),
    }
```

HR workflows may also:

* Trigger or link to `HrCase` rows (Doc 1 Module 11) based on subtype/label.
* Use broadcast labels only for high‑level updates, not for work creation.

---

## 8. Checklist for Domain Modules (Doc 3 Compliance)

For **each** domain module, the following must hold:

* [ ] Directory `domain_modules/<domain>/` exists; `<domain>` matches `Task.type`.

* [ ] `<domain>_module.yaml`:

  * [ ] `domain` field = directory name.
  * [ ] `allowed_categories` ⊆ `{request, incident, update, report, distribution}`.
  * [ ] `default_category ∈ allowed_categories`.
  * [ ] `allowed_subtypes` present (may be empty) and used as `Task.subtype` values.
  * [ ] `default_visibility` and `allowed_visibility` ⊆ `{public, internal, restricted, anonymised}` and align with org profile constraints.
  * [ ] `email_patterns` defined if the domain handles email.
  * [ ] No redefinition of global enums (TASK_STATUS, TASK_PRIORITY, TASK_SEVERITY, VISIBILITY, CASE_STATUS).

* [ ] `<domain>_handler.py`:

  * [ ] Implements required functions: `on_task_create`, `on_task_created`, `on_task_update`, `on_task_updated`, `get_domain_fields`.
  * [ ] Uses only canonical Task/Case fields and enums.
  * [ ] Reads/writes `subtype` via `Task.subtype` (not hidden metadata).
  * [ ] Does not bypass visibility rules; only suggests defaults within allowed range.
  * [ ] Does not directly manipulate DB; uses core services.

* [ ] Broadcast labels:

  * [ ] Domain‑specific behaviour for broadcast bases (10/100/1000) is configured in workflow rules, not ad‑hoc code.
  * [ ] Broadcast‑labeled items are non‑actionable unless a documented rule explicitly enables `auto_create_tasks: true`.

* [ ] Multi‑tenancy:

  * [ ] All queries/operations are scoped by `organization_id` as provided in `DomainContext`.

This version of **Doc 3 – Domain Modules (Orgo v3)** is aligned with:

* Canonical DB schema (Doc 1),
* Global enums and Task/Case models (Doc 2),
* Core Services (Doc 5),
* Labeling + broadcast semantics and state machines (Doc 8),
* Profiles and Insights behaviour (Docs 6–7 and profile configs).

===== END 3-orgo-full-stack-technical-spec.md (#0003) =====

===== BEGIN 4-orgo-functional-code-name-inventory.md (#0004) =====
﻿<!-- INDEX: Doc 4 – Functional Code‑Name Inventory (Services & Hooks) -->
Index

Document role (mapping product features → code artifacts)

Naming conventions (locked for Orgo v3)
2.1 Backend (NestJS) naming
2.2 Frontend (NextJS + RTK Query) naming
2.3 Cross‑cutting constants (functional IDs)

Main functional inventory table
3.1 Backbone: Multi‑tenant org, users & persons
3.2 Signals & ingestion (Email, API, offline)
3.3 Cases, Tasks, Workflow & labels
3.4 Configuration, profiles & global parameters
3.5 Interfaces (API, web, live updates)
3.6 Domain Modules (maintenance, HR, education, generic domain API)
3.7 Insights, analytics & cyclic overview
3.8 Infrastructure, monitoring & guardrails (health, metrics, alerts, security & compliance, validation)

How to use these code names
4.1 Backend services
4.2 Frontend hooks
4.3 Background jobs & queues
4.4 Cross‑module references
4.5 Governance for new features



# Orgo v3 – Functional Code‑Name Inventory (Services & Hooks)

**Document 4 of 8 – Orgo v3 Blueprint**

This document is the mapping for the Orgo v3 TypeScript implementation (NestJS + Prisma + NextJS + RTK Query). It does not redefine schemas or enums; those are locked in:

* **Doc 1 – Database Schema Reference** (all tables, including `tasks`, `cases`, labeling, offline & insights star‑schema). 
* **Doc 2 – Foundations, Locked Variables & Operational Checklists** (canonical enums, canonical Task field set, log and visibility enums, configuration and global checklists). 
* **Doc 3 – Domain Modules (Orgo v3)** (thin adapters over the central Task/Case engine). 
* **Doc 5 – Core Services Specification** (email gateway, task handler, workflow engine, notifier, logger, persistence). 
* **Doc 6 – Insights Module Config Parameters and the profiles YAML** (analytics & behavioural profiles). 
* **Doc 8 – Cyclic Overview & Universal Flow Rules** (label semantics, JSON contracts, cyclic reviews). 

---

## 1. Document Role

This document is the Rosetta stone between Orgo’s **conceptual features** and the TypeScript/NestJS/NextJS code that implements them:

* Multi‑tenant backbone (organizations, user accounts vs person profiles).
* Signals in → Cases & Tasks out (email/API/offline → workflow → Case/Task).
* Label system and routing (`<base>.<category><subcategory>.<horizontal_role>`).
* Domain modules as thin adapters over the global Task/Case engine.
* Profiles (friend_group, hospital, advocacy_group, retail_chain, etc.) that tune reactivity, transparency, reviews, and automation.
* Insights & cyclic overview (star schema, ETL/Airflow, pattern detection feeding back into new Cases/Tasks).
* Guardrails (VISIBILITY, logging, audit, compliance exports).
TypeScript examples assume Prisma as the ORM (`DatabaseService.getPrismaClient` etc.), but the functional inventory and the underlying schemas/enums remain ORM-neutral.


It maps:

* Product / UX feature names (“Route crisis email into a safety Case & Tasks”, “Run monthly pattern review”)
  to
* Backend services, background jobs, and frontend hooks in the Orgo v3 stack.

All modules, services, jobs, and hooks in Orgo v3 must use the code names defined here. If implementation diverges, this document is the source of truth. 

---

## 2. Naming Conventions (Locked for Orgo v3)

### 2.1 Backend (NestJS)

* **Service classes**: `PascalCaseService`
  Example: `EmailService`, `WorkflowEngineService`, `TaskService`, `CaseService`.

* **Controller classes**: `PascalCaseController`
  Example: `TaskController`, `CaseController`.

* **Public methods**: `camelCaseVerbNoun`
  Example: `sendEmail`, `parseEmail`, `executeWorkflow`, `createCaseFromSignal`.

* **NestJS path** (convention, not enforced by framework):

  * `apps/api/src/orgo/<module>/<submodule>.service.ts`
  * `apps/api/src/orgo/<module>/<module>.controller.ts`

* **Queue job names (string IDs)**:

  * `orgo.<module>.<action>` (all lowercase, dot‑separated).
    Example: `orgo.email.poll`, `orgo.task.escalate`, `orgo.insights.weekly-pattern-review`.

### 2.2 Frontend (NextJS + RTK Query)

* **API slice**: `orgoApi`
  `apps/web/src/store/services/orgoApi.ts` (extends the existing RTK Query setup).

* **Query hooks**: `use<Entity>Query`
  Example: `useTasksQuery`, `useCasesQuery`, `useWorkflowExecutionHistoryQuery`.

* **Mutation hooks**: `useVerbEntityMutation`
  Example: `useCreateTaskMutation`, `useCreateCaseMutation`, `useUpdateTaskStatusMutation`.

### 2.3 Cross‑cutting constants

* **Stable function IDs** (for logs, analytics, configuration references):

  * `FN_<MODULE>_<ACTION>` – e.g., `FN_EMAIL_SEND`, `FN_WORKFLOW_EXECUTE`, `FN_CASE_CREATE`.

* Shared constants file:

  * `apps/api/src/orgo/core/functional-ids.ts`
  * `apps/web/src/orgo/core/functional-ids.ts` (mirrored).



---

## 3. Main Functional Inventory Table

Format per row:

* **Module** – Top‑level business area (Backbone, Core Services, Domain Modules, Insights, etc.).
* **Sub‑module** – Logical engine or feature group.
* **Display Name → Code Name** – Human feature name mapped to explicit code identifier(s).
* **Purpose / Behaviour** – 1–2 line description of what it does and how it fits the Orgo “nervous system”.

Where both backend and frontend artifacts exist, they are listed together in the “Code Name” part. 

---

### 3.1 Backbone: Multi‑Tenant Org, Users & Persons

| Module       | Sub‑module          | Display Name → Code Name                                                                                                                                                            | Purpose / Behaviour                                                                                                                                 |
| ------------ | ------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Backbone** | Organizations       | Manage organizations (tenants) → `OrganizationService.createOrganization`, `OrganizationService.updateOrganization`, hooks `useOrganizationsQuery`, `useCreateOrganizationMutation` | Creates and updates `organizations` rows (slug, display name, timezone, default profile linkage, status) and enforces one active profile per org.   |
| Backbone     | Persons             | Manage person profiles → `PersonProfileService.upsertPersonProfile`, hook `usePersonProfileQuery`                                                                                   | Manages `person_profiles` (people tasks/cases are about: students, players, employees, community members), whether or not they have login accounts. |
| Backbone     | Identity & RBAC     | Manage roles and permissions → `RoleService.createRole`, `PermissionService.assignPermission`, hook `useRolesQuery`                                                                 | Maintains `roles`, `permissions`, and `role_permissions`; powers RBAC decisions for tasks, cases, insights, and exports.                            |
| Backbone     | User–Person linking | Link user accounts to person profiles → `IdentityLinkService.linkUserToPerson`, hook `useLinkUserPersonMutation`                                                                    | Connects `user_accounts` and `person_profiles` so tasks/cases can refer to the human subject separately from the Orgo login identity.               |



---

### 3.2 Signals & Ingestion (Email, API, Offline)

| Module            | Sub‑module       | Display Name → Code Name                                                                                                          | Purpose / Behaviour                                                                                                                                    |
| ----------------- | ---------------- | --------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Core Services** | Email Handling   | Send notification email → `EmailService.sendEmail` (Nest), job `orgo.email.send`, hook `useSendTestEmailMutation`                 | Sends transactional and workflow‑related emails via SMTP using organization‑specific configuration.                                                    |
| Core Services     | Email Handling   | Parse incoming email → `EmailParserService.parseIncoming`, job `orgo.email.parse`                                                 | Parses raw incoming email payloads into normalized Orgo email objects (`email_messages` + attachments) for routing.                                    |
| Core Services     | Email Handling   | Validate email payload → `EmailValidatorService.validateEmailPayload`                                                             | Ensures subject, sender, body, and attachments respect validation rules and size/type limits from email config.                                        |
| Core Services     | Email Handling   | Poll mailbox for new messages → `EmailIngestService.pollMailbox`, job `orgo.email.poll`                                           | Connects to IMAP, fetches new messages, stores them in `email_messages`, and enqueues parsing + workflow routing.                                      |
| Core Services     | Email Handling   | Route email to workflow → `EmailRouterService.routeToWorkflow`                                                                    | Maps parsed emails to workflow contexts using org/domain patterns, labels, and profile hints.                                                          |
| Core Services     | API / Signals    | Ingest API / UI signal → `SignalIngestService.ingest`, controller `SignalController.createSignal`, hook `useCreateSignalMutation` | Normalizes non‑email signals (REST, UI forms, webhooks) into a common “signal” shape that workflows can turn into Cases/Tasks.                         |
| Core Services     | Offline & Import | Import email archive (PST/mbox) → `EmailArchiveImportService.importArchive`, job `orgo.email.import-archive`                      | Processes offline mail archives (`email_archive_import_batches`, `imported_message_mappings`) into `email_messages` for historical analysis and cases. |
| Core Services     | Offline & Sync   | Sync offline node → `SyncService.syncOfflineNode`, job `orgo.sync.run-node`                                                       | Reconciles SQLite‑backed offline nodes with central Postgres using `offline_nodes`, `sync_sessions`, and `sync_conflicts`.                             |
| Core Services     | Offline & Sync   | Sync offline task cache → `SyncService.syncOfflineTasks`, job `orgo.db.sync-offline`                                              | Applies queued offline task changes into the online `tasks` table, then hydrates local caches with authoritative state.                                |



---

### 3.3 Cases, Tasks, Workflow & Labels

| Module            | Sub‑module      | Display Name → Code Name                                                                                       | Purpose / Behaviour                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| ----------------- | --------------- | -------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Core Services** | Case Management | Create Case from signal → `CaseService.createCaseFromSignal`, hook `useCreateCaseMutation`                     | Creates a `cases` row from an incoming signal or pattern, assigning `source_type`, `label`, CASE_STATUS (`open`,`in_progress`,`resolved`,`archived`), severity, and reactivity fields according to org profile.                                                                                                                                                                                                                                                                                                                                                           |
| Core Services     | Case Management | Fetch Case with linked Tasks → `CaseService.getCaseWithTasks`, hook `useCaseDetailsQuery`                      | Returns a Case plus its linked `tasks`, labels, and participants, used by generic Case UIs and domain‑specific case views (e.g. HR).                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| Core Services     | Case Management | Run cyclic Case review → `CaseReviewService.runCyclicReview`, job `orgo.cases.cyclic-review`                   | Implements weekly/monthly/yearly Case review passes defined in Doc 8, creating audit/review Cases when thresholds are crossed instead of just emitting metrics.                                                                                                                                                                                                                                                                                                                                                                                                           |
| Core Services     | Workflow Engine | Execute workflow → `WorkflowEngineService.executeWorkflow`, job `orgo.workflow.execute`                        | Executes workflow definitions over tasks/cases (routing, metadata updates, escalation), logging each action via the `WORKFLOW` log category.                                                                                                                                                                                                                                                                                                                                                                                                                              |
| Core Services     | Workflow Engine | Validate workflow definition → `WorkflowEngineService.validateWorkflow`                                        | Ensures workflow rules only use canonical enums (TASK_STATUS, TASK_PRIORITY, TASK_SEVERITY, VISIBILITY) and valid actions.                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Core Services     | Workflow Engine | Simulate workflow run → `WorkflowEngineService.simulate`, hook `useWorkflowSimulationMutation`                 | Runs a dry‑run of a workflow on sample data to preview created Tasks, routing, and escalations without persisting changes.                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| Core Services     | Workflow Engine | Evaluate escalation rules → `EscalationService.evaluateEscalations`, job `orgo.workflow.check-escalations`     | Periodically checks Tasks against `reactivity_deadline_at` and escalation policies, then drives status `ESCALATED` transitions and notifications.                                                                                                                                                                                                                                                                                                                                                                                                                         |
| Core Services     | Task Management | Create Task from event → `TaskService.createTask`, hook `useCreateTaskMutation`                                | Creates a Task from a signal/workflow using the canonical Task field set (`task_id`, `organization_id`, `case_id`, `type`, `category`, `subtype`, `label`, `title`, `description`, `status`, `priority`, `severity`, `visibility`, `source`, `created_by_user_id`, `requester_person_id`, `owner_role_id`, `owner_user_id`, `assignee_role`, `due_at`, `reactivity_time`, `reactivity_deadline_at`, `escalation_level`, `closed_at`, `metadata`); initializes `status = PENDING` and computes `reactivity_deadline_at` from `reactivity_time` and the active org profile. |
| Core Services     | Task Management | Update Task status → `TaskService.updateTaskStatus`, hook `useUpdateTaskStatusMutation`                        | Changes a Task’s status using the TASK_STATUS enum (`PENDING`,`IN_PROGRESS`,`ON_HOLD`,`COMPLETED`,`FAILED`,`ESCALATED`,`CANCELLED`), enforcing the canonical state machine and logging transitions as `task_events`.                                                                                                                                                                                                                                                                                                                                                      |
| Core Services     | Task Management | Escalate Task → `TaskService.escalateTask`, job `orgo.task.escalate`                                           | Increments `escalation_level`, sets `status = ESCALATED`, attaches escalation events, and triggers notifications to higher‑level roles defined in policies and profiles.                                                                                                                                                                                                                                                                                                                                                                                                  |
| Core Services     | Task Management | Add Task comment → `TaskService.addComment`, hook `useAddTaskCommentMutation`                                  | Appends structured comments in `task_comments`, respecting per‑comment visibility (`internal_only`,`requester_visible`,`org_wide`) and audit requirements.                                                                                                                                                                                                                                                                                                                                                                                                                |
| Core Services     | Task Management | Fetch Task details → `TaskService.getTaskById`, hook `useTaskDetailsQuery`                                     | Returns a Task plus metadata, label, workflow history, escalation status, comments, and linked Case/Persons for detailed views.                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| Core Services     | Label & Routing | Resolve canonical label & routing → `LabelRoutingService.resolveLabel`, `RoutingRuleService.applyRoutingRules` | Given a signal or Task draft, computes the canonical label (`<base>.<category><subcategory>.<horizontal_role>`) and applies `routing_rules` to choose an owning role/queue.                                                                                                                                                                                                                                                                                                                                                                                               |
| Core Services     | Label & Routing | Manage classification labels → `LabelService.createLabelDefinition`, hook `useLabelDefinitionsQuery`           | Manages `label_definitions`/`entity_labels` used for risk/topics tags and pattern detection, separate from the single canonical information label on Cases/Tasks.                                                                                                                                                                                                                                                                                                                                                                                                         |
| Core Services     | Database Ops    | Connect to primary DB → `DatabaseService.getPrismaClient`                                                      | Central entry to Prisma backed by validated `database_connection` config (Postgres 15+, optional SQLite for offline dev).                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Core Services     | Database Ops    | Run CRUD on entity → `RepositoryFactory.getRepository(entity).<op>`                                            | Generic repositories for create/read/update/delete over Orgo entities (Tasks, Cases, Persons, etc.), always using parameterized queries.                                                                                                                                                                                                                                                                                                                                                                                                                                  |



---

### 3.4 Configuration, Profiles & Global Parameters

| Module                       | Sub‑module    | Display Name → Code Name                                                                                  | Purpose / Behaviour                                                                                                                                                               |
| ---------------------------- | ------------- | --------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Configuration & Profiles** | Org Profiles  | Load organization profile → `OrgProfileService.loadProfile`                                               | Loads each org’s active profile (`friend_group`, `hospital`, `advocacy_group`, `retail_chain`, etc.), including reactivity, transparency, pattern sensitivity, and logging depth. |
| Configuration & Profiles     | Org Profiles  | Apply profile defaults → `OrgProfileService.applyDefaults`                                                | Applies profile‑driven defaults (priority, severity, visibility, SLA, automation) when creating Tasks/Cases and when scheduling cyclic reviews.                                   |
| Configuration & Profiles     | Org Profiles  | Preview profile impact → `OrgProfileService.previewProfileDiff`, hook `useProfilePreviewMutation`         | Simulates profile changes and shows impact on escalation timings, notification scope, retention, and insights pattern sensitivity.                                                |
| Configuration & Profiles     | Config Store  | Fetch global configuration → `ConfigService.getGlobalConfig`, hook `useGlobalConfigQuery`                 | Returns merged base + environment + org config from `parameter_overrides`, email/logging/DB configs, and module overlays.                                                         |
| Configuration & Profiles     | Config Store  | Update service configuration → `ConfigService.updateServiceConfig`, hook `useUpdateServiceConfigMutation` | Persists configuration changes (email, workflows, insights, notifications), validates them, and writes audit records.                                                             |
| Configuration & Profiles     | Config Store  | Import configuration bundle → `ConfigService.importConfigBundle`, job `orgo.config.import-bundle`         | Imports YAML/JSON config bundles (including profiles and insights settings), validates against schema, and activates as a single atomic change set.                               |
| Configuration & Profiles     | Feature Flags | Toggle feature flags → `FeatureFlagService.setFlag`, hook `useFeatureFlagsQuery`                          | Manages `feature_flags` to gradually roll out new modules (e.g. new insights dashboards, domain modules) per org.                                                                 |



---

### 3.5 Interfaces (API, Web, Live Updates)

| Module                     | Sub‑module    | Display Name → Code Name                                                                                                       | Purpose / Behaviour                                                                                     |
| -------------------------- | ------------- | ------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------- |
| **Interfaces (API & Web)** | Public API    | Get Tasks (list) → `TaskController.listTasks`, hook `useTasksQuery`                                                            | `GET /api/v3/tasks` with filters for status, label, domain, assignee, severity, visibility.             |
| Interfaces (API & Web)     | Public API    | Get single Task → `TaskController.getTask`, hook `useTaskDetailsQuery`                                                         | `GET /api/v3/tasks/:id` returning full Task + related Case metadata.                                    |
| Interfaces (API & Web)     | Public API    | Create Task via API → `TaskController.createTask`, hook `useCreateTaskMutation`                                                | `POST /api/v3/tasks` for direct Task creation (not email‑backed), using canonical Task model and enums. |
| Interfaces (API & Web)     | Public API    | Get Cases (list) → `CaseController.listCases`, hook `useCasesQuery`                                                            | `GET /api/v3/cases` for listing Cases, including filters for CASE_STATUS, label, severity.              |
| Interfaces (API & Web)     | Public API    | Get single Case → `CaseController.getCase`, hook `useCaseDetailsQuery`                                                         | `GET /api/v3/cases/:id` returning Case + linked Tasks, labels, and participants.                        |
| Interfaces (API & Web)     | Public API    | Trigger workflow execution → `WorkflowController.execute`, hook `useExecuteWorkflowMutation`                                   | `POST /api/v3/workflows/:id/execute` for manual workflow runs over a Case/Task context.                 |
| Interfaces (API & Web)     | Admin UI      | Admin Task overview → component `AdminTaskOverviewPage`, hook `useAdminTaskOverviewQuery`                                      | Cross‑domain Task queues with filters by status, domain type, label, role, priority, severity.          |
| Interfaces (API & Web)     | Admin UI      | Case overview → component `AdminCaseOverviewPage`, hook `useAdminCaseOverviewQuery`                                            | High‑level Case list used for cyclic reviews and systemic pattern follow‑up.                            |
| Interfaces (API & Web)     | Admin UI      | Profile configuration screen → `AdminProfileConfigController`, hooks `useOrgProfilesQuery`, component `OrgProfileSettingsPage` | Admin view to inspect and edit org profiles and preview their operational & insights impact.            |
| Interfaces (API & Web)     | Notifications | Send in‑app notification → `NotificationService.sendInApp`, hook `useNotificationsFeedQuery`                                   | Delivers notifications into Orgo UI (banner/toast) alongside email/SMS channels.                        |
| Interfaces (API & Web)     | Notifications | Subscribe to live Task updates → `TaskEventsGateway` (WebSocket), hook `useTaskEventStream`                                    | Streams Task events (status changes, comments, escalations) to the UI in near real‑time.                |



---

### 3.6 Domain Modules (Maintenance, HR, Education, …)

| Module             | Sub‑module         | Display Name → Code Name                                                                                                   | Purpose / Behaviour                                                                                                                |
| ------------------ | ------------------ | -------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
| **Domain Modules** | Maintenance        | Register maintenance incident → `MaintenanceModuleService.registerIncident`, hook `useRegisterMaintenanceIncidentMutation` | Thin wrapper around `TaskService.createTask` for `type = "maintenance"`, setting domain_subtype and asset metadata.                |
| Domain Modules     | Maintenance        | List maintenance incidents → `MaintenanceModuleService.listIncidents`, hook `useMaintenanceIncidentsQuery`                 | Domain‑filtered Task list for `type = "maintenance"`, including asset links and inspection tickets.                                |
| Domain Modules     | HR                 | Register HR report → `HrModuleService.registerReport`, hook `useRegisterHrReportMutation`                                  | Creates Task(s) + optional HR Case with anonymisation/visibility rules appropriate for HR workflows.                               |
| Domain Modules     | HR                 | List HR Cases → `HrModuleService.listCases`, hook `useHrCasesQuery`                                                        | Returns HR‑scoped Cases/Tasks and escalation history for compliance and review.                                                    |
| Domain Modules     | Education          | Register student incident → `EducationModuleService.registerStudentIncident`, hook `useRegisterStudentIncidentMutation`    | Wraps Task creation for education incidents, attaching `learning_group`/person context metadata.                                   |
| Domain Modules     | Education          | List classroom incidents → `EducationModuleService.listIncidents`, hook `useEducationIncidentsQuery`                       | Returns Tasks scoped to education domain, enriched with group/person context for dashboards and reviews.                           |
| Domain Modules     | Generic Domain API | Generic domain Task factory → `DomainTaskFactory.createDomainTask`                                                         | Shared abstraction used by all domain modules to construct domain‑specific Task metadata views on top of the canonical Task model. |
| Domain Modules     | Generic Domain API | Domain workflow override → `DomainWorkflowService.applyOverrides`                                                          | Applies domain‑specific overrides (e.g. tighter HR reactivity, different escalation levels) on top of global workflow rules.       |



---

### 3.7 Insights, Analytics & Cyclic Overview

| Module                   | Sub‑module      | Display Name → Code Name                                                                                           | Purpose / Behaviour                                                                                      |
| ------------------------ | --------------- | ------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------- |
| **Insights / Analytics** | Reporting API   | Get Task volume report → `ReportsService.getTaskVolumeReport`, hook `useTaskVolumeReportQuery`                     | Aggregates `insights.fact_tasks` into time buckets by domain/status for dashboards.                      |
| Insights / Analytics     | Reporting API   | Get escalation SLA breaches → `ReportsService.getSlaBreaches`, hook `useSlaBreachReportQuery`                      | Returns Tasks that breached profile‑defined SLAs (reactivity or completion), grouped by domain.          |
| Insights / Analytics     | Reporting API   | Get profile effectiveness score → `ReportsService.getProfileScore`, hook `useProfileScoreQuery`                    | Computes how well an org profile meets its reaction/resolution targets using insights fact tables.       |
| Insights / Analytics     | Star Schema     | Export facts to warehouse → `AnalyticsExportService.exportFacts`, job `orgo.analytics.export-facts`                | Periodically exports `fact_*` tables (tasks, cases, escalations, wellbeing) to analytics DB/warehouse.   |
| Insights / Analytics     | Star Schema     | Refresh materialized views → `AnalyticsExportService.refreshMaterializedViews`, job `orgo.analytics.refresh-views` | Refreshes derived views over `insights.fact_*` and `insights.dim_*` for fast dashboard queries.          |
| Insights / Analytics     | Cyclic Patterns | Run weekly pattern review → `PatternDetectionService.runWeekly`, job `orgo.insights.weekly-pattern-review`         | Implements the weekly cyclic overview: detects short‑window patterns and creates new audit/review Cases. |
| Insights / Analytics     | Cyclic Patterns | Run monthly trend report → `PatternDetectionService.runMonthly`, job `orgo.insights.monthly-trend-report`          | Implements monthly pattern detection for trends by label, domain, location, severity.                    |
| Insights / Analytics     | Cyclic Patterns | Run yearly systemic review → `PatternDetectionService.runYearly`, job `orgo.insights.yearly-systemic-review`       | Implements yearly systemic pattern detection; results are turned into leadership‑level review Cases.     |
| Insights / Analytics     | Dashboard UI    | Overview dashboard → component `InsightsOverviewPage`, hook `useInsightsOverviewQuery`                             | Frontend entry point summarizing workload, SLAs, patterns, and cross‑domain risks per organization.      |
| Insights / Analytics     | Cache Warmup    | Warm dashboard caches → `InsightsCacheWarmupService.warmDashboards`, job `orgo.insights.cache-warmup-dashboards`   | Pre‑warms Redis caches for high‑traffic dashboards using TTLs from insights config.                      |

---

### 3.8 Infrastructure, Monitoring & Guardrails

| Module                          | Sub‑module         | Display Name → Code Name                                                                                           | Purpose / Behaviour                                                               |
| ------------------------------- | ------------------ | ------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------- |
| **Infrastructure & Monitoring** | Health & Readiness | API healthcheck endpoint → `HealthController.getHealth` (`GET /api/v3/health`)                                     | Returns aggregated status of DB, queues, config loader, domain modules, insights. |
| Infrastructure & Monitoring     | Health & Readiness | Worker heartbeat job → `WorkerHealthService.heartbeat`, job `orgo.worker.heartbeat`                                | Sends heartbeats from workers and logs anomalies for ops dashboards.              |
| Infrastructure & Monitoring     | Metrics            | Collect workflow latency metrics → `MetricsService.recordWorkflowLatency`                                          | Records per‑workflow latency metrics and sends them to Prometheus/observability.  |
| Infrastructure & Monitoring     | Metrics            | Collect Task queue depth → `MetricsService.recordQueueDepth`                                                       | Measures per‑queue depth (email, workflow, Task) for autoscaling and alerting.    |
| Infrastructure & Monitoring     | Alerts             | Trigger escalation delay alert → `AlertingService.triggerEscalationDelayAlert`, job `orgo.alerts.escalation-delay` | Emits alerts when escalations fall behind SLAs from profiles/config.              |
| Infrastructure & Monitoring     | Alerts             | Trigger error‑rate alert → `AlertingService.triggerErrorRateAlert`, job `orgo.alerts.error-rate`                   | Emits alerts when error rates across services exceed configured thresholds.       |

| Module                    | Sub‑module             | Display Name → Code Name                                                                                      | Purpose / Behaviour                                                                                                           |
| ------------------------- | ---------------------- | ------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| **Security & Compliance** | Authentication & RBAC  | Authenticate API request → `AuthGuard.validateAccessToken`                                                    | Validates tokens for API requests, attaches user/org context, and enforces multi‑tenant scoping.                              |
| Security & Compliance     | Authentication & RBAC  | Enforce role permissions → `RbacService.checkPermission`                                                      | Checks that a role may perform a given action on a resource (Task, Case, workflow, config).                                   |
| Security & Compliance     | Privacy                | Anonymise sensitive fields → `PrivacyService.anonymizePayload`                                                | Applies org/profile‑specific anonymisation rules for HR and other sensitive workflows, consistent with VISIBILITY enum.       |
| Security & Compliance     | Privacy                | Generate audit trail entry → `AuditTrailService.recordAuditEvent`                                             | Writes security‑relevant audit events (config changes, permission changes, exports) to dedicated audit logs/tables.           |
| Security & Compliance     | Compliance             | Export audit log for regulator → `ComplianceExportService.exportAuditLog`, job `orgo.compliance.export-audit` | Prepares filtered, visibility/PII‑respecting audit log exports for regulators and external reviewers.                         |
| Security & Compliance     | Data Export Guardrails | Export analytics slice → `InsightsExportService.exportAnalytics`, job `orgo.insights.export-analytics`        | Runs controlled exports from analytics views enforcing `allowed_visibilities` and row limits from insights config.            |
| Security & Compliance     | Logging                | Log system event → `LogService.logEvent`, constant `FN_LOG_SYSTEM_EVENT`                                      | Writes normalized log entries (`timestamp`,`level`,`category`,`message`,`identifier`) with categories from LOG_CATEGORY enum. |
| Security & Compliance     | Logging                | Log security event → `LogService.logSecurityEvent`                                                            | Logs authentication, RBAC, escalation, and export events to `security_events` for long‑term retention.                        |
| Security & Compliance     | Logging                | Rotate logs → `LogRotationService.rotateLogs`, job `orgo.logs.rotate`                                         | Enforces log retention/rotation policies per category (WORKFLOW,TASK,SYSTEM,SECURITY,EMAIL).                                  |
| Security & Compliance     | Logging                | Fetch activity log for entity → `LogQueryService.getActivityForEntity`, hook `useEntityLogQuery`              | Returns `activity_logs` / `task_events` for a specific entity for troubleshooting and reviews.                                |
| Security & Compliance     | Validation             | Validate configuration set → `ConfigValidatorService.validateConfigBundle`                                    | Validates configuration bundles (workflow rules, insights config, profiles) against required keys and enums.                  |
| Security & Compliance     | Validation             | Validate incoming API payload → `PayloadValidationPipe`                                                       | Validates DTOs for Tasks, Cases, workflows, and imports at controller boundaries.                                             |
| Security & Compliance     | Validation             | Normalize Task metadata → `MetadataService.normalizeMetadata`                                                 | Normalizes free‑form Task metadata to avoid conflicts with canonical Task fields and enums.                                   |



---

## 4. How To Use These Code Names

1. **Backend services**

   * When adding a new method to a service, choose the Module/Sub‑module from this document and reuse or extend an existing naming pattern (`TaskService.updateTaskStatus` rather than inventing `changeTaskState`).
   * When creating a new service, ensure the class and file name follow the conventions in §2 and add a row here.

2. **Frontend hooks**

   * All Orgo v3 data fetching must be implemented as RTK Query endpoints in `orgoApi` using the hook naming patterns listed above.
   * When designing a new screen, first identify the needed hooks in this inventory (for example, “Admin Case overview → `useAdminCaseOverviewQuery`”) and implement those; do not invent one‑off fetchers.

3. **Background jobs and queues**

   * Queue job identifiers must match the `orgo.<module>.<action>` names listed in the tables.
   * Worker handlers (Bull, RabbitMQ, etc.) and Airflow DAG wrappers must reference these job IDs and be documented against them.

4. **Cross‑module references**

   * When configuration, tests, or docs refer to a feature, they should use:

     * The **display name** in human‑facing docs (“Run monthly trend report”).
     * The **code name** (`PatternDetectionService.runMonthly`, job `orgo.insights.monthly-trend-report`) in technical references (logs, config keys, test names).

5. **Governance**

   * Any new feature that introduces:

     * A new backend service method,
     * A new RTK Query endpoint/hook, or
     * A new background job or Airflow DAG,

     must add a corresponding row to this inventory as part of the pull request. Code review should block merges until the inventory remains consistent with the implementation and with the canonical schemas/enums in Docs 1–2. 

===== END 4-orgo-functional-code-name-inventory.md (#0004) =====

===== BEGIN 5-orgo-Core-Services-Specification.md (#0005) =====
﻿Updated Doc 5 with the requested changes is below.

````markdown
﻿<!-- INDEX: Doc 5 – Core Services Specification -->
Index

Scope & status
0.1 Alignment with other docs

Core Services – high‑level overview
1.1 Email Gateway Service (email_gateway)
1.2 Task Handler Service (task_handler)
1.3 Workflow Engine Service (workflow_engine)
1.4 Notification Service (notifier_service)
1.5 Persistence Service (persistence)
1.6 Logging & Audit Service (logger_service)
1.7 Validation & Security Support (validation_core)

Shared conventions (locked for v3)
2.1 Naming & case conventions
2.2 Environments (ENVIRONMENT)
2.3 Common data types
2.4 Standard result shape (ok / data / error)
2.5 Config boundaries (Core vs Domain vs Insights)

Canonical data models (logical views)
3.1 TASK (logical view over tasks)
– Status, priority, severity, visibility enums
3.2 EMAIL_MESSAGE (logical envelope over email tables)
3.3 LOG_EVENT (logical log entry schema)

Email Gateway Service (email_gateway)
4.1 Responsibilities
4.2 Configuration (email_config.yaml)
4.3 Public functions (fetch, parse, validate, send)
4.4 Validation rules & error codes

Task Handler Service (task_handler)
5.1 Responsibilities
5.2 Core state machine (allowed transitions)
5.3 SLA derivation & escalation checks
5.4 Public functions (create, update status, escalate, assign, add comment)
5.5 Required task attributes & validation

Workflow Engine Service (workflow_engine)
6.1 Responsibilities
6.2 Rule structure & matching semantics
6.3 Supported action types
6.4 API surface (execute, validate rules)

Notification Service (notifier_service)
7.1 Responsibilities
7.2 Configuration (notification_config.yaml)
7.3 Public functions (send_task_notification)

Persistence Service (persistence)
8.1 Responsibilities
8.2 Configuration (database_connection.yaml) & invariants
8.3 Core functions (connect, fetch, insert, update)

Logging & Audit Service (logger_service)
9.1 Responsibilities
9.2 Logging configuration (logging_config.yaml)
9.3 Public functions (log_event, rotate_logs)
9.4 Example log entry

Validation & Security Support (validation_core)
10.1 Responsibilities
10.2 Config validation
10.3 Input validation examples

Cross‑service flow example (email → task → escalation)

Non‑functional requirements (performance, reliability, testing)

Extensibility guidelines (new domains, notification channels, analytics jobs)


# **Document 5/8: Core Services Specification**

> (“Core Services” = everything headless and backend that powers workflows, tasks, emails, logs, and core config.)

---

## 0. Scope & Status

* **Document ID**: `orgo-v3-core-services`
* **Role in set**: **5/8** (Core Services)
* **Version**: `3.0.1`
* **Applies to**: All Orgo v3 deployments (small teams → large orgs)
* **Non-goals**:

  * UI layouts (dashboards, web clients) – covered in **Interfaces / Frontend docs**.
  * Low-level infra (containers, K8s, etc.) – covered in **Infrastructure / Ops docs**.
  * Domain-specific behavior beyond configuration (Maintenance, HR, etc.) – handled via **domain modules + workflow rules**.

Core Services are **headless**. They expose APIs and internal services consumed by Interfaces, Domain Modules, Insights, and Infrastructure.

### 0.1 Alignment With Other Docs

This document **does not define** its own enums or physical table shapes. It assumes:

* **Physical schemas**:

  * `tasks`, `cases`, `email_messages`, `activity_logs`, `security_events`, `offline_nodes`, `sync_sessions`, etc. – from **Doc 1 – Database Schema Reference (Custom Tables)**.
* **Canonical enums & Task/Case field sets**:

  * `TASK_STATUS`, `TASK_PRIORITY`, `TASK_SEVERITY`, `VISIBILITY`, `ENVIRONMENT`, canonical Task/Case JSON shapes – from **Doc 2 – Foundations, Locked Variables & Operational Checklists** and **Doc 8 – Cyclic Overview, Labels & Universal Flow Rules**.
* **Domain module contracts**:

  * Directory layout, `<domain>_module.yaml`, `<domain>_handler.py`, and DomainTask mapping – from **Doc 3 – Domain Modules (Orgo v3)**.
* **Functional code names** (NestJS/NextJS implementation):

  * Service / controller / job names – from **Doc 4 – Functional Code‑Name Inventory**.
* **Insights & analytics behaviour**:

  * Star‑schema, analytics retention, ETL DAGs, export limits – from **Doc 6 – Insights Module Config Parameters** and profiles in **Doc 7 – Profiles YAML**.

Whenever this doc mentions **TASK**, **CASE**, or **EMAIL_MESSAGE**, it is referring to those canonical models.

If anything in this file contradicts **Docs 1/2/8**, those docs **win** and this document must be updated.

---

## 1. Core Services – High-Level Overview

Core Services are the “backend spine” of Orgo v3:

1. **Email Gateway Service (`email_gateway`)**

   * Receives and sends emails; parses and validates email payloads.

2. **Task Handler Service (`task_handler`)**

   * Creates, updates, escalates, and tracks tasks (unified, metadata‑driven).

3. **Workflow Engine Service (`workflow_engine`)**

   * Evaluates routing & escalation rules; orchestrates workflow steps.

4. **Notification Service (`notifier_service`)**

   * Delivers email / in‑app notifications based on events and rules.

5. **Persistence Service (`persistence`)**

   * Provides Postgres + SQLite connectors, CRUD helpers, and offline sync hooks.

6. **Logging & Audit Service (`logger_service`)**

   * Unified logging, audit trails, and retention enforcement.

7. **Validation & Security Support (`validation_core`)**

   * Cross‑cutting config & payload validation utilities plus basic auth/authorization hooks
     (full security spec lives in the Security / RBAC docs, but Core Services must integrate cleanly).

All domain‑specific logic (HR, maintenance, education, etc.) must be expressed through:

* **Workflow rules** (`/config/workflows/*.yaml`)
* **Domain module configs & handlers** (`domain_modules/<domain>/<domain>_module.yaml`, `<domain>_handler.py`)
* **Templates** (`/templates/email/*.html`, domain templates)

Core Services **must not** hardcode domain‑specific branches.

---

## 2. Shared Conventions (Locked for v3)

### 2.1 Naming & Case

* **Environment variables**: `ORGO_*` (all caps, snake_case).

* **Config keys (YAML/JSON)**: snake_case (`reactivity_time`, `notification_scope`).

* **Database columns**: snake_case (`organization_id`, `created_at`).

* **Enum values in DB**: canonical tokens from Doc 2 (`PENDING`, `HIGH`, `CRITICAL`, `PUBLIC`, `ANONYMISED`, etc.).

* **JSON/UX representation**:

  * Lower‑case strings are permitted in API/JSON (e.g. `"pending"`, `"high"`, `"anonymised"`).
  * They must map 1:1 to DB enums (e.g. `"pending"` ↔ `PENDING`).

* **Service identifiers** (internal registry, logs): lower_snake (`task_handler`, `email_gateway`).

These conventions are **locked** for v3; the rest of the docs assume them.

### 2.2 Environments

Canonical environment values (Doc 2):

```text
ENVIRONMENT = { "dev", "staging", "prod", "offline" }
````

* All configuration examples in this doc use these values.
* Human‑readable prose may say “development” or “production”, but config values are always one of the four above.

### 2.3 Common Data Types

* `UUID`: canonical ID type for entities.
* `TIMESTAMP_UTC`: ISO8601 in UTC (e.g., `2025-11-18T10:30:00Z`).
* `JSONB`: arbitrary JSON (for Postgres); serialized JSON (for SQLite).
* `LABEL_CODE`: string like `100.34.Finance.Audit` (see labels in Doc 8).

### 2.4 Standard Result Shape (Internal / API)

All Core Service functions that can fail synchronously **should** return:

```json
{
  "ok": true,
  "data": { /* result payload */ },
  "error": null
}
```

or

```json
{
  "ok": false,
  "data": null,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Missing required field 'subject'",
    "details": { "field": "subject" }
  }
}
```

The shape (`ok`, `data`, `error`) is **locked** for v3.

### 2.5 Config Boundaries (Global vs Module vs Insights)

* **Core Services config** in this doc:

  * Email gateway, DB connections, core logging, workflow engine, queues, Core notification config.

* **Domain modules config** (Doc 3):

  * Maintenance/HR/education module configs (`domain_modules/.../*_module.yaml`) and their handler logic.

* **Insights/analytics config** (Doc 6):

  * Analytics retention, reporting windows, pattern windows, export limits, DAG schedules.

Where overlapping concepts exist (e.g. *retention*):

* **Operational log & task retention / rotation** → this doc (Core Services).
* **Analytics retention / reporting windows** → Insights doc (Doc 6).
* **Profile‑driven behaviour** (reactivity, transparency, cyclic overview) → Profiles / Doc 7 with parameters consumed by both Core Services and Insights.

When in doubt: domain‑specific or reporting‑specific parameters live outside this doc; this doc governs **cross‑domain, headless services**.

---

## 3. Canonical Data Models (Logical Views)

These are **logical views** of the canonical DB schemas from Doc 1, using the enums and JSON contracts from Docs 2 and 8.

### 3.1 TASK (Logical View)

**Physical table**: `tasks` (Doc 1; PK column is `id`).

**Logical view (fields Core Services care about):**

```text
task_id               UUID                PK (logical; maps to tasks.id)
organization_id       UUID                NOT NULL
case_id               UUID                NULL        -- links to cases.id

created_at            TIMESTAMP_UTC       NOT NULL
updated_at            TIMESTAMP_UTC       NOT NULL

type                  TEXT                NOT NULL    -- domain type: "maintenance", "hr_case", "it_support", etc.
category              TEXT                NOT NULL    -- "request" | "incident" | "update" | "report" | "distribution"
subtype               TEXT                NULL        -- e.g. "plumbing", "harassment", "attendance"

label                 TEXT                NOT NULL    -- "<base>.<category><subcategory>.<horizontal_role>"
title                 TEXT                NOT NULL
description           TEXT                NOT NULL

status                task_status_enum    NOT NULL    -- PENDING|IN_PROGRESS|ON_HOLD|COMPLETED|FAILED|ESCALATED|CANCELLED
priority              task_priority_enum  NOT NULL    -- LOW|MEDIUM|HIGH|CRITICAL
severity              task_severity_enum  NOT NULL    -- MINOR|MODERATE|MAJOR|CRITICAL

visibility            visibility_enum     NOT NULL    -- PUBLIC|INTERNAL|RESTRICTED|ANONYMISED
source                task_source_enum    NOT NULL    -- email|api|manual|sync (stored lower-case in DB)

created_by_user_id    UUID                NULL        -- FK → user_accounts.id
requester_person_id   UUID                NULL        -- FK → person_profiles.id

owner_role_id         UUID                NULL        -- FK → roles.id (primary owning role)
owner_user_id         UUID                NULL        -- FK → user_accounts.id (primary owner)
assignee_role         TEXT                NULL        -- e.g. "Ops.Maintenance" (denormalized routing label; current primary routing label)

due_at                TIMESTAMP_UTC       NULL
reactivity_time       INTERVAL            NULL        -- derived from profiles/workflows
reactivity_deadline_at TIMESTAMP_UTC      NULL        -- usually created_at + reactivity_time
escalation_level      INTEGER             NOT NULL DEFAULT 0   -- 0 = none, 1+ depth in escalation path
closed_at             TIMESTAMP_UTC       NULL

metadata              JSONB               NOT NULL    -- domain-specific; must not duplicate core fields
```

* JSON representation for Tasks at the API boundary is given in **Doc 8 §8.4.2** (Task JSON Schema); this doc only fixes the **service‑side expectations**.
* `source` in this doc always refers to `task_source_enum` (`email` | `api` | `manual` | `sync`), not to workflow event sources (`EMAIL` | `API` | `SYSTEM`), which are separate.
* Assignment history (including concrete assignee users) lives in `task_assignments`; the `Task` row only carries the current `owner_role_id` / `owner_user_id` and a denormalised `assignee_role` convenience field.

#### 3.1.1 Task Status (Locked Enum)

`task_status_enum` (Doc 1/2):

```text
PENDING
IN_PROGRESS
ON_HOLD
COMPLETED
FAILED
ESCALATED
CANCELLED
```

* JSON representation MAY use lower‑case (e.g. `"pending"`), but must map to these values.

#### 3.1.2 Priority & Severity (Locked Enums)

`task_priority_enum`:

```text
LOW
MEDIUM
HIGH
CRITICAL
```

`task_severity_enum`:

```text
MINOR
MODERATE
MAJOR
CRITICAL
```

In examples we sometimes show `priority` / `severity` as `TEXT`; read that as **“backed by these enums”**, not arbitrary strings.

#### 3.1.3 Visibility (Locked Enum)

`visibility_enum`:

```text
PUBLIC
INTERNAL
RESTRICTED
ANONYMISED
```

* **RESTRICTED** replaces earlier “PRIVATE” terminology (“minimal set of users/roles who need access”).
* API/JSON MAY expose lower‑case (`"restricted"`, `"anonymised"`), but these map directly to the DB enum.

#### 3.1.4 Legacy `scope` Classification (Non‑Normative)

Earlier v2/v3 drafts used a conceptual classification:

```text
"UNIVERSAL" | "CROSS_INDUSTRY" | "SPECIFIC"
```

For v3:

* This classification is **optional metadata only**, not part of the canonical `tasks` schema.
* If needed, store under `metadata.scope` as a string.
* Core Services do **not** rely on it, and profiles do not use it; it is purely descriptive/analytical.

---

### 3.2 EMAIL_MESSAGE (Logical Envelope)

**Physical tables** (Doc 1, Module 3):

* `email_messages` (core metadata and bodies)
* `email_attachments` (attachments)
* `email_processing_events` (parsing/classification/linkage events)

Core Services operate on a logical `EMAIL_MESSAGE` envelope that wraps the main row in `email_messages` plus selected derived fields:

```text
email_message_id        UUID           PK (logical; maps to email_messages.id)
organization_id         UUID           NOT NULL
email_account_config_id UUID           NULL        -- FK → email_account_configs.id
thread_id               UUID           NULL        -- FK → email_threads.id

message_id_header       TEXT           NULL        -- RFC822 Message-ID

direction               email_direction_enum NOT NULL  -- 'inbound' | 'outbound' (lower-case in DB)

from_address            TEXT           NOT NULL
to_addresses            TEXT[]         NOT NULL
cc_addresses            TEXT[]         NULL
bcc_addresses           TEXT[]         NULL

subject                 TEXT           NOT NULL
received_at             TIMESTAMP_UTC  NULL        -- for inbound
sent_at                 TIMESTAMP_UTC  NULL        -- for outbound

raw_headers             TEXT           NULL
text_body               TEXT           NULL        -- normalized plain text
html_body               TEXT           NULL        -- may be truncated; full content may live in blob storage

related_task_id         UUID           NULL        -- FK → tasks.id
sensitivity             TEXT           NOT NULL    -- 'normal' | 'sensitive' | 'highly_sensitive'

parsed_metadata         JSONB          NOT NULL    -- classifier results, label candidates, extraction, etc.
attachments_meta        JSONB          NOT NULL    -- array of attachment metadata objects, aggregated from email_attachments
security_flags          JSONB          NOT NULL    -- e.g. { "pgp_encrypted": true, "spam_score": 0.1 }
```

* In the physical DB, `direction` is a PostgreSQL ENUM with values `'inbound'` / `'outbound'` (lower‑case) as per Doc 1; services may expose upper‑case constants, but persisted values must match the schema.
* Any additional ingestion metadata (e.g. raw archive IDs) may live in `email_ingestion_batches` / `imported_message_mappings`; services may surface it via `parsed_metadata` if needed.

Core Services (`email_gateway`, `workflow_engine`, `task_handler`) must use this logical envelope and **must not** invent a divergent email schema.

---

### 3.3 LOG_EVENT (Logical)

Log entries may be stored in files or in tables such as `activity_logs` and `security_events`, but the logical schema emitted by `logger_service` is:

```json
{
  "timestamp": "2025-11-18T10:30:00Z",
  "level": "INFO",
  "category": "WORKFLOW",
  "message": "Task created",
  "identifier": "task_id:7b45-...",
  "metadata": {
    "workflow_name": "maintenance_default",
    "actor": "system"
  }
}
```

* `level` must be one of `LOG_LEVEL = { "DEBUG","INFO","WARNING","ERROR","CRITICAL" }` (Doc 2).
* `category` must be one of `LOG_CATEGORY = { "WORKFLOW","TASK","SYSTEM","SECURITY","EMAIL" }` (Doc 2).

---

## 4. Email Gateway Service (`email_gateway`)

### 4.1 Responsibilities

* Fetch incoming messages via IMAP/POP or offline files/archives.
* Validate and parse messages into `EMAIL_MESSAGE` envelopes.
* Sanitize content & enforce plain‑text‑first processing.
* Send outgoing notifications via SMTP.
* Handle errors with retries and exponential backoff.
* Append ingestion/processing events (`email_ingestion_batches`, `email_processing_events`).

### 4.2 Configuration (Locked Keys & Metadata)

**YAML file**: `/config/email/email_config.yaml`

```yaml
metadata:
  config_name: "email_config"
  version: "3.0"                 # must match ^3\.[0-9]+$ (Doc 2)
  environment: "dev"             # dev | staging | prod | offline
  last_updated: "2025-11-18"     # YYYY-MM-DD
  owner: "core-services-team"
  organization_id: "default"

smtp:
  host: "smtp.example.org"
  port: 587
  use_tls: true
  use_ssl: false
  username_env: "ORGO_SMTP_USERNAME"
  password_env: "ORGO_SMTP_PASSWORD"
  connection_timeout_secs: 10
  send_timeout_secs: 30
  max_retries: 3
  retry_backoff_secs: 2

imap:
  host: "imap.example.org"
  port: 993
  use_ssl: true
  username_env: "ORGO_IMAP_USERNAME"
  password_env: "ORGO_IMAP_PASSWORD"
  connection_timeout_secs: 10
  read_timeout_secs: 60
  folder: "INBOX"

limits:
  max_email_size_mb: 10
  allowed_attachment_mimetypes:
    - "application/pdf"
    - "image/png"
    - "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
```

Notes / invariants (aligning with Doc 2 §3.4):

* `metadata.environment` ∈ `{dev,staging,prod,offline}`.
* `metadata.version` matches `^3\.[0-9]+$`.
* `metadata.last_updated` is `YYYY-MM-DD`.
* Credentials are **never** stored as raw strings here; only via `*_env`.
* `limits.max_email_size_mb > 0` and `allowed_attachment_mimetypes` is non‑empty.

### 4.3 Public Functions (Conceptual Signatures)

```python
def fetch_incoming_emails(max_count: int) -> dict:
    """
    Fetches up to `max_count` raw email messages from IMAP/POP.
    Returns standard result shape with a list of raw messages in data.
    """

def parse_email(raw_email: dict) -> dict:
    """
    Parses a raw email into a structured EMAIL_MESSAGE-like payload
    matching the canonical email_messages + attachments model.
    Required keys in result: subject, from_address, to_addresses, text_body.
    """

def validate_email(parsed_email: dict) -> dict:
    """
    Validates the email payload; fails if required fields are missing
    or the message exceeds configured size / attachment limits.
    Respects limits.max_email_size_mb and allowed_attachment_mimetypes.
    """

def send_email(to: list[str], subject: str, body: str,
               cc: list[str] | None = None,
               bcc: list[str] | None = None) -> dict:
    """
    Sends an email via SMTP using the configured account.
    """
```

### 4.4 Validation Rules (Email)

* Required fields: `subject`, `from_address`, `to_addresses`, **and** either `text_body` or `html_body` convertible to text.
* Max total size: **10MB** (configurable via `limits.max_email_size_mb`).
* Allowed attachment types: `limits.allowed_attachment_mimetypes`.
* Sanitization:

  * Strip dangerous HTML/JS.
  * Normalize to plain text in `text_body` for downstream processing.

Common error codes:

* `EMAIL_VALIDATION_ERROR`
* `EMAIL_PARSING_ERROR`
* `EMAIL_SEND_FAILED`

---

## 5. Task Handler Service (`task_handler`)

### 5.1 Responsibilities

* Create tasks from email/API/workflow events.
* Manage the **canonical Task state machine** (Doc 8 §8.5.2).
* Trigger escalations and notifications.
* Provide a consistent API for all modules & interfaces.
* Enforce multi‑tenant isolation and visibility rules on every operation.

### 5.2 Core State Machine (Locked)

Allowed transitions (must match Doc 8 §8.5.2 exactly):

* `PENDING` → `IN_PROGRESS`, `CANCELLED`
* `IN_PROGRESS` → `ON_HOLD`, `COMPLETED`, `FAILED`, `ESCALATED`
* `ON_HOLD` → `IN_PROGRESS`, `CANCELLED`
* `ESCALATED` → `IN_PROGRESS`, `COMPLETED`, `FAILED`
* `COMPLETED`, `FAILED`, `CANCELLED` → (terminal)

Any invalid transition must return (standard result shape):

```json
{
  "ok": false,
  "data": null,
  "error": {
    "code": "INVALID_TASK_STATE_TRANSITION",
    "message": "Transition IN_PROGRESS → PENDING is not allowed"
  }
}
```

### 5.2.1 SLA derivation and escalation checks

Core Services derive `reactivity_time` and `reactivity_deadline_at` when creating a Task by combining:

* the organization’s active profile (reactivity_seconds, severity_policy),
* workflow rules, and
* any domain-specific hints.

The canonical rule is:

```text
reactivity_deadline_at = created_at + reactivity_time
```

Escalation jobs MUST compare the current time against the stored `reactivity_deadline_at` for unresolved Tasks, rather than recomputing SLA deadlines on the fly from profile values. This keeps operational behaviour aligned with analytics and cyclic overview semantics in Doc 8.

### 5.3 Public Functions (Logical)

```python
def create_task(payload: dict) -> dict:
    """
    Creates a new task.

    Required (core) fields in payload (canonical Task JSON):
      - organization_id (UUID)
      - type (str)         # domain-type, e.g. "maintenance"
      - category (str)     # "request" | "incident" | "update" | "report" | "distribution"
      - title (str)
      - description (str)
      - priority (str)     # "LOW" | "MEDIUM" | "HIGH" | "CRITICAL" (or lower-case JSON forms)
      - severity (str)     # "MINOR" | "MODERATE" | "MAJOR" | "CRITICAL"
      - visibility (str)   # PUBLIC|INTERNAL|RESTRICTED|ANONYMISED (or lower-case)
      - label (str)        # canonical label "<base>.<category><subcategory>.<horizontal_role>"
      - source (str)       # "email" | "api" | "manual" | "sync"
      - metadata (dict)

    Optional:
      - case_id, subtype, due_at,
        created_by_user_id, requester_person_id,
        owner_role_id, owner_user_id,
        assignee_role

    Derived:
      - status = PENDING
      - escalation_level = 0
      - reactivity_time, reactivity_deadline_at based on org profile + workflows.
    """

def update_task_status(task_id: str, new_status: str,
                       *, reason: str | None = None,
                       actor_user_id: str | None = None) -> dict:
    """
    Updates the status of a task, enforcing the state machine rules
    and appending a TaskEvent row.
    """

def escalate_task(task_id: str, *,
                  reason: str,
                  actor_user_id: str | None = None) -> dict:
    """
    Escalates the task along its defined escalation path.

    Effects:
      - increments escalation_level (>= 1),
      - sets status = ESCALATED,
      - records escalation events (task_events, escalation_* tables),
      - may trigger notifications (via notifier_service).
    """

def assign_task(task_id: str,
                assignee_role: str | None = None,
                *,
                actor_user_id: str | None = None,
                assignee_user_id: str | None = None) -> dict:
    """
    Assigns or reassigns a task to a role and/or user.

    If provided, assignee_user_id is recorded only in TaskAssignment history;
    the Task logical view and canonical Task JSON remain free of assignee_user_id
    and carry only owner_* and assignee_role.

    Effects:
      - updates tasks.assignee_role (denormalised routing label),
      - appends a TaskAssignment row (records any user-level assignment),
      - records a TaskEvent (ownership_changed).
    """

def add_task_comment(task_id: str,
                  comment: str,
                  author_user_id: str,
                  visibility: str = "internal_only") -> dict:
    """
    Appends a comment to task_comments for auditability and collaboration.

    `visibility` must be one of the COMMENT_VISIBILITY enum values
    (`internal_only`, `requester_visible`, `org_wide`) defined in Doc 2.
    """
```

### 5.4 Required Task Attributes (Validation)

Minimal required keys for `create_task` (beyond `organization_id`):

* `type`
* `category`
* `title`
* `description`
* `priority`
* `severity`
* `visibility`
* `label`
* `source`
* `metadata`

On validation failure:

* Return `ok=false` and `error.code = "TASK_VALIDATION_ERROR"`.

---

## 6. Workflow Engine Service (`workflow_engine`)

### 6.1 Responsibilities

* Load and merge global + organization + domain‑specific workflow rules.
* Validate rule structure and enum usage.
* Evaluate rules on context (email, task events, timers).
* Produce a deterministic list of actions (`CREATE_TASK`, `ROUTE`, `ESCALATE`, `NOTIFY`, etc.).
* Log workflow execution steps under `LOG_CATEGORY = WORKFLOW`.

Broadcast labels (bases `10`, `100`, `1000`) are informational by default.

### 6.2 Rule Structure (Locked Keys)

Each rule (conceptual YAML):

```yaml
id: "maintenance_default_v3"
version: "3.0.0"
match:
  source: "EMAIL"             # EMAIL | API | SYSTEM | TIMER (workflow event source, not task_source_enum)
  type: "maintenance"         # domain-level type (NOT the category enum)
  category: "request"         # optional; one of canonical task categories
  severity: "CRITICAL"        # optional; canonical severity enum
  keywords_any:
    - "hvac"
    - "heat"
    - "cooling"
actions:
  - type: "CREATE_TASK"
    set:
      priority: "CRITICAL"
      reactivity_time: "1 hour"
  - type: "ROUTE"
    to_role: "Ops.Maintenance"
  - type: "NOTIFY"
    channel: "EMAIL"
    template_id: "task_assignment"
```

Important points:

* Where earlier drafts used `category: "maintenance"` under `match`, that is **fixed** to `type: "maintenance"`.
* `category` is reserved for `"request" | "incident" | "update" | "report" | "distribution"` (global Task categories).
* Rule evaluation must respect canonical enums from Doc 2 / Doc 8; invalid enum values must cause rule validation errors.

### 6.3 Supported ACTION Types

Core action types the engine must support:

* `CREATE_TASK`
* `UPDATE_TASK`
* `ROUTE`
* `ESCALATE`
* `ATTACH_TEMPLATE`
* `SET_METADATA`
* `NOTIFY`

Implementations may add more **internal** action types, but configuration and logs should stick to this set unless extended and documented.

### 6.4 API Surface (Logical)

```python
def execute_workflow(context: dict) -> dict:
    """
    Given a context (email / task event / system timer, including organization_id),
    evaluates all matching rules in deterministic order and returns an ordered list
    of actions to apply (without side-effects).

    The caller (e.g. task_handler, email_gateway) is responsible for applying actions
    transactionally and logging outcomes.
    """

def validate_workflow_rules() -> dict:
    """
    Validates workflow rule files (YAML/JSON) for:
      - required top-level keys (id, version, match, actions),
      - canonical enums (status, category, priority, severity, visibility),
      - internal consistency (no unknown action types, required fields per action).
    Returns the standard result shape.
    """
```

---

## 7. Notification Service (`notifier_service`)

### 7.1 Responsibilities

* Implement the **Task‑driven notifications** portion of Core Services.

* Send email + in‑app notifications for:

  * Task creation
  * Assignment / reassignment
  * Escalation
  * Completion

* Respect:

  * `NOTIFICATION_CHANNEL` + `NOTIFICATION_SCOPE` from Doc 2, and
  * `visibility` and org profiles (`notification_scope`, transparency) from Doc 7.

### 7.2 Configuration (Locked Keys)

Core notification config lives in Core Services; analytics/reporting notifications (e.g. “report ready”) live in **Insights** (Doc 6).

**YAML file**: `/config/notifications/notification_config.yaml`

```yaml
metadata:
  config_name: "notification_config"
  version: "3.0"
  environment: "prod"
  last_updated: "2025-11-18"
  owner: "core-services-team"
  organization_id: "default"

notifications:
  default_channel: "EMAIL"     # EMAIL is mandatory; others optional
  channels:
    email:
      enabled: true
      sender_name: "Orgo System"
      sender_address: "no-reply@example.org"
    in_app:
      enabled: true
    # sms / webhook channels can be added as needed; mobile push is modelled via IN_APP plus client delivery

  templates:
    task_created: "task_created.html"
    task_assignment: "task_assignment.html"
    task_escalation: "task_escalation.html"
    task_completed: "task_completed.html"
```

### 7.3 Public Functions

```python
def send_task_notification(task: dict, event_type: str) -> dict:
    """
    Sends notifications for a task lifecycle event.

    event_type: "CREATED" | "ASSIGNED" | "ESCALATED" | "COMPLETED"

    Channel selection & recipient set are determined by:
      - notification_config (default_channel, enabled channels),
      - task.visibility,
      - org profile notification_scope,
      - task ownership/assignment (owner_role_id, owner_user_id, assignee_*).

    Returns the standard result shape with delivery metadata.
    """
```

---

## 8. Persistence Service (`persistence`)

### 8.1 Responsibilities

* Manage connections to **Postgres** (online OLTP) and **SQLite** (offline nodes).
* Provide safe CRUD helpers with parameterized queries.
* Enforce multi‑tenant filters (`organization_id`).
* Support conflict resolution & coordination with offline sync tables (`offline_nodes`, `sync_sessions`, `sync_conflicts`) defined in Doc 1.

### 8.2 Configuration (Locked Keys & Invariants)

**YAML file**: `/config/database/database_connection.yaml`

```yaml
metadata:
  config_name: "database_connection"
  version: "3.0"
  environment: "staging"
  last_updated: "2025-11-18"
  owner: "core-services-team"
  organization_id: "default"

postgres:
  enabled: true
  url_env: "DATABASE_URL"          # full URI (for ORM / drivers)
  host: "postgres"
  port: 5432
  database: "orgo"
  schema: "public"
  user_env: "ORGO_DB_USER"
  password_env: "ORGO_DB_PASSWORD"
  pool:
    min_connections: 1
    max_connections: 20
    idle_timeout_seconds: 300

sqlite:
  enabled: false                    # invariant: NOT (postgres.enabled and sqlite.enabled)
  file_path: "./data/orgo_offline.db"
  timeout_seconds: 5
```

Invariants (aligning with Doc 2 §3.3):

* Exactly one of `postgres.enabled` / `sqlite.enabled` may be `true` in a given process.
* For Postgres, `pool.min_connections <= pool.max_connections`.
* For SQLite, `file_path` must be writable in the environment.

### 8.3 Core Functions (Logical)

```python
def connect_to_database(*, mode: str = "ONLINE") -> object:
    """
    mode:
      - "ONLINE": use Postgres (requires postgres.enabled = true),
      - "OFFLINE": use SQLite (requires sqlite.enabled = true).

    Returns a connection / pool object or raises on failure.
    """

def fetch_records(table: str,
                  where: dict | None = None,
                  *,
                  mode: str = "ONLINE") -> dict:
    """
    Executes a parameterized SELECT based on `where` conditions.

    Returns:
      - ok: true/false
      - data: list of rows (as dicts)
    """

def insert_record(table: str,
                  data: dict,
                  *,
                  mode: str = "ONLINE") -> dict:
    """
    Executes an INSERT with validation; returns the inserted primary key
    (e.g. task_id) in data on success.
    """

def update_record(table: str,
                  key: dict,
                  updates: dict,
                  *,
                  mode: str = "ONLINE") -> dict:
    """
    Executes a parameterized UPDATE based on a primary key / unique key filter.
    """
```

All queries must be **parameterized** to prevent SQL injection.

---

## 9. Logging & Audit Service (`logger_service`)

### 9.1 Responsibilities

* Provide a single `log_event` entry point for structured logs.
* Support categories: `WORKFLOW`, `TASK`, `SYSTEM`, `SECURITY`, `EMAIL`.
* Enforce retention policies and rotation at the file/sink layer.
* Feed security‑relevant events to dedicated tables (`security_events`, `activity_logs`) as appropriate.

### 9.2 Configuration

Core logging config:

```yaml
metadata:
  config_name: "logging_config"
  version: "3.0"
  environment: "prod"
  last_updated: "2025-11-18"
  owner: "core-services-team"
  organization_id: "default"

logging:
  level: "INFO"                # DEBUG | INFO | WARNING | ERROR | CRITICAL
  format: "json"               # json | text
  log_dir: "./logs"

categories:
  WORKFLOW:
    file: "workflow_activity.log"
    retention_days: 180
    rotation: "weekly"         # daily | weekly | size
    max_file_size_mb: 50
  TASK:
    file: "task_execution.log"
    retention_days: 365
    rotation: "weekly"
    max_file_size_mb: 50
  SYSTEM:
    file: "system_activity.log"
    retention_days: 180
    rotation: "weekly"
    max_file_size_mb: 50
  SECURITY:
    file: "security_events.log"
    retention_days: 730
    rotation: "weekly"
    max_file_size_mb: 20
  EMAIL:
    file: "email_events.log"
    retention_days: 180
    rotation: "weekly"
    max_file_size_mb: 50
```

Analytics‑specific log/metric retention (for Insights / dashboards) is configured in **Doc 6 – Insights Module Config**, not here.

### 9.3 Public Functions

```python
def log_event(
    *,
    category: str,    # "WORKFLOW" | "TASK" | "SYSTEM" | "SECURITY" | "EMAIL"
    log_level: str,   # "DEBUG" | "INFO" | "WARNING" | "ERROR" | "CRITICAL"
    message: str,
    identifier: str | None = None,
    metadata: dict | None = None
) -> None:
    """
    Writes a structured log entry according to the standard schema
    (timestamp, level, category, message, identifier, metadata).

    The persisted JSON field name for the level MUST be `level`
    to align with Doc 2 / Doc 8 examples.
    """

def rotate_logs() -> None:
    """
    Performs log rotation and deletion based on per-category retention policies.
    """
```

### 9.4 Example Log Entry (Fixed Casing + Field Names)

```json
{
  "timestamp": "2025-11-18T10:30:00Z",
  "level": "INFO",
  "category": "WORKFLOW",
  "message": "Task created",
  "identifier": "task_id:f9e6fc7d-12ab-4b9f-a4db-3f1ecf3f2a89",
  "metadata": {
    "workflow_name": "maintenance_default",
    "actor": "system"
  }
}
```

---

## 10. Validation & Security Support (`validation_core`)

### 10.1 Responsibilities

* Validate configuration files for required keys and basic schema.
* Provide reusable input validators (emails, tasks, workflows).
* Provide hooks for auth checks (role‑based, token‑based) consumed by higher‑level security modules.

### 10.2 Config Validation

```python
def validate_config(config: dict, required_keys: list[str]) -> dict:
    """
    Ensures required_keys are present and not null in the config object.

    Must also enforce:
      - metadata.environment ∈ ENVIRONMENT
      - metadata.version matches ^3\\.[0-9]+$
      - metadata.last_updated is a valid YYYY-MM-DD date

    On failure:
      - returns ok=false, error.code="CONFIG_VALIDATION_ERROR"
      - logs a SYSTEM-level error via logger_service.
    """
```

Applies to (non‑exhaustive):

* `email_config.yaml`
* `database_connection.yaml`
* `logging_config.yaml`
* `notification_config.yaml`
* Workflow rule bundles (`/config/workflows/*.yaml`)
* Org profile configs (profiles YAML / Doc 7) and Insights config (`/config/insights/config.yaml`).

### 10.3 Input Validation Examples

Typical validators (all returning the standard result shape):

* `validate_email(parsed_email)` – against EMAIL_MESSAGE logical schema.
* `validate_task_payload(payload)` – checks fields against canonical Task JSON (Doc 8 §8.4.2).
* `validate_workflow_rule(rule_obj)` – structure, enums, actions.
* `validate_notification_payload(payload)` – correct channels and visibility.

---

## 11. Cross-Service Flow Example (Locked Pattern)

Example: **Maintenance request via email → Task → Escalation**

1. **Email Reception**

   * `email_gateway.fetch_incoming_emails(max_count=50)`
   * For each raw email:

     * `parse_email(raw) → parsed_email`
     * `validate_email(parsed_email)`

2. **Persist + Log**

   * `persistence.insert_record("email_messages", parsed_email)`
     (plus attachments and processing events as needed)
   * `logger_service.log_event(
       category="EMAIL",
       log_level="INFO",
       message="Email received",
       identifier=f"email_message_id:{parsed_email['email_message_id']}"
     )`

3. **Workflow Execution**

   * Build context: `{ "source": "EMAIL", "organization_id": <org>, "email": parsed_email }`
   * `workflow_engine.execute_workflow(context) → actions`

4. **Apply Actions**

   * For `CREATE_TASK`: `task_handler.create_task(task_payload)`
   * For `ROUTE`: `task_handler.assign_task(task_id, assignee_role=...)`
   * For `NOTIFY`: `notifier_service.send_task_notification(task, event_type="CREATED")`

5. **Escalation**

   * Background job checks unresolved tasks whose `reactivity_deadline_at` has passed.
   * If overdue:

     * `task_handler.escalate_task(task_id, reason="Reactivity time exceeded")`
     * `notifier_service.send_task_notification(task, event_type="ESCALATED")`
     * `logger_service.log_event(
         category="WORKFLOW",
         log_level="WARNING",
         message="Task escalated",
         identifier=f"task_id:{task_id}"
       )`

This pattern is **canonical** and reused across domains; domain modules plug in only through config and handlers, not by changing this flow.

---

## 12. Non-Functional Requirements

* **Performance**

  * Core Services should support at least:

    * ~50k tasks/day on a mid‑range server.
    * Email parsing throughput ≥ 10 messages/s sustained on reference hardware.

* **Reliability**

  * Critical operations (task creation, escalation, logging) should be idempotent where possible.
  * Failed external calls (SMTP, IMAP, webhooks) must be retried with backoff and logged with `LOG_LEVEL >= WARNING`.

* **Testing**

  * Unit tests for each core function (`parse_email`, `create_task`, `execute_workflow`, etc.).
  * Integration tests for end‑to‑end flows:

    * email → Task → notification → escalation,
    * API Task creation → workflow routing → Insights ingestion.

---

## 13. Extensibility Guidelines (v3)

To add new behaviour without touching core logic:

1. **New Task Types / Domains**

   * Add domain types in workflow rules (`type: "maintenance"`, `"hr_case"`, etc.).
   * Extend or add domain modules under `domain_modules/<domain>/` with `<domain>_module.yaml` and `<domain>_handler.py` (Doc 3).
   * Use `metadata` and domain link tables (`maintenance_task_links`, `education_task_links`, etc.) for domain‑specific fields (Doc 1).

2. **New Domain Modules**

   * Directory: `domain_modules/<domain>/`.

   * Provide:

     * `<domain>_module.yaml` – config (categories, subtypes, email patterns, routing hints).
     * `<domain>_handler.py` – hooks (`on_task_create`, `on_task_created`, `on_task_update`, `on_task_updated`, `get_domain_fields`).
     * Any templates / additional rule files referenced from the module config (no implicit paths).

   * Reuse shared **task_handler** and **workflow_engine**; do not implement your own lifecycles.

3. **New Notification Templates / Channels**

   * Add templates under `/templates/email/` or equivalent.
   * Reference them via `template_id` in workflow `NOTIFY` actions and notification config.
   * For new channels (SMS, webhook, push), extend `notifications.channels` and ensure they honour `VISIBILITY` and `NOTIFICATION_SCOPE`.

4. **New Analytics / Pattern Jobs**

   * Must use the existing Insights star schema and config (Doc 6) and feed back into Cases/Tasks via Core Services in a way that respects cyclic overview semantics (Doc 8).

Core Services remain the **single shared backbone**; all extensions must plug into it rather than bypass it.

```

:contentReference[oaicite:0]{index=0}
```

===== END 5-orgo-Core-Services-Specification.md (#0005) =====

===== BEGIN 6-orgo-insights-module-config-parameters.md (#0006) =====
﻿<!-- INDEX: Doc 6 – Insights Module Config Parameters (Orgo v3) -->
Index

Scope, dependencies and baseline
1.1 Scope of Insights module
1.2 Canonical enums overlay for Insights
1.3 Documentation dependencies & cross‑references
1.4 Orgo v3 Insights tech stack baseline

Configuration parameters and invariants
2.1 Data retention and purge (analytics layer)
2.2 Backup and recovery policies
2.3 Cache TTLs and aggregation windows
2.4 Export limits and privacy safeguards
2.5 Access control and routing invariants
2.6 Environment‑specific defaults overview

Insights config schema (/config/insights/config.yaml)
3.1 Top‑level structure (insights: subtree)
3.2 Profiles and pattern settings (default_profile_key, overrides_by_domain)

ETL and Airflow job configuration
4.1 DAG inventory (daily/weekly/monthly/yearly jobs, cache warmup)
4.2 Job‑level constraints and invariants

Environment variables and secrets (Insights slice)

Deployment, scaling and monitoring (Insights slice)
6.1 Runtime components
6.2 Scaling policies
6.3 Monitoring metrics and alerts

Cross‑document alignment notes
7.1 Tech stack alignment
7.2 Enum consistency
7.3 Profiles vs Insights config
7.4 Environment‑specific defaults vs global ENVIRONMENT


# Document 6 – Insights Module Config Parameters (Orgo v3)

This document defines configuration parameters and operational constraints for the **Insights / Analytics module** in Orgo v3.

It is a **module‑scoped parameter overlay** on top of:

* Doc 1 – Database Schema Reference (Custom Tables; includes the `insights.*` star schema).
* Doc 2 – Foundations, Locked Variables & Operational Checklists (enums, `ENVIRONMENT`, config invariants).
* Doc 7 – Organization Profiles & Cyclic Overview Settings (profiles schema and pre‑configured profiles).
* Doc 8 – Cyclic Overview, Labels & Universal Flow Rules (Case/Task JSON contracts, cyclic review semantics, pattern rules).

Core services (task ingestion, routing, workflow engine, email gateway, domain modules) are specified in Docs 3–5. This document **does not redefine core behaviour**; it only configures how Insights/analytics ingest, store, aggregate and expose data.

---

## 1. Scope, Dependencies and Baseline

### 1.1 Scope

The Insights module covers:

* Analytical storage (star schema, materialized views, pattern tables).
* ETL and Airflow jobs that hydrate the analytics warehouse / star schema.
* Pattern detection and cyclic overview computations.
* Read‑only reporting APIs and caches used by dashboards.
* Module‑specific retention, backup and export limits for analytics data.

Out of scope here:

* Core operational task/case tables (Doc 1).
* Global parameter matrix and environment definitions (Doc 2).
* UI page specifications and dashboard layouts (interface/UX and frontend documentation).
* API contracts for the reporting service (`reports-api`) (see code/API mapping in Doc 4 and related interface docs).
* Infrastructure and monitoring details beyond what is needed to parameterize Insights (Core Services / infrastructure & operations documentation, including Doc 5).

### 1.2 Canonical Enums Overlay for Insights

The Insights module **reuses** the global enums defined in Doc 2. For clarity, they are restated here and must remain identical to Doc 2.

**TASK_STATUS**

* `PENDING`
* `IN_PROGRESS`
* `ON_HOLD`
* `COMPLETED`
* `FAILED`
* `ESCALATED`
* `CANCELLED`

**TASK_PRIORITY**

* `LOW`
* `MEDIUM`
* `HIGH`
* `CRITICAL`

**TASK_SEVERITY**

* `MINOR`
* `MODERATE`
* `MAJOR`
* `CRITICAL`

**VISIBILITY**

* `PUBLIC`
* `INTERNAL`
* `RESTRICTED`
* `ANONYMISED`

**ENVIRONMENT**

* `"dev"`
* `"staging"`
* `"prod"`
* `"offline"`

Rules:


 * Analytics tables in the `insights.*` schema store the **same tokens** as the operational enums, but as **TEXT** columns (even on Postgres) to decouple the warehouse from OLTP enum DDL.
 * For non‑Postgres warehouses (`warehouse.type != "postgres"`), the values MUST appear as the **exact same tokens** at rest (upper‑snake), stored as generic string types.
* Any change to these enums in Doc 2 must be mirrored in this section and in the analytics DDL in Doc 1 (Module 14 – Analytics / Insights Star‑Schema) and any derived warehouse schemas.

### 1.3 Documentation Dependencies and Cross‑References

This document assumes the following:

* **Doc 1 – Database Schema Reference (Custom Tables)**

  * Defines `insights.*` tables (facts, dimensions, pattern tables, materialized views).
  * Parameters in this document such as retention windows and partitioning assumptions apply to those tables.

* **Doc 2 – Foundations, Locked Variables & Operational Checklists**

  * Is the **canonical source** for enums listed in §1.2 and for `ENVIRONMENT`.
  * Defines global config structure/validation and guardrails (visibility, audit, exports).
  * This document only declares module‑specific defaults; it does not introduce new enum values.

* **Doc 7 – Organization Profiles & Cyclic Overview Settings**

  * Defines the **profiles schema** (YAML `profiles:`) and the pre‑configured profiles (`friend_group`, `hospital`, `advocacy_group`, `retail_chain`, etc.).
  * This document references those profile keys as configuration values (e.g. `default_profile_key`, overrides).

* **Doc 8 – Cyclic Overview, Labels & Universal Flow Rules**

  * Defines:

    * Label semantics and Case/Task JSON contracts at the API boundary.
    * Task and Case status lifecycles and allowed transitions.
    * Cyclic overview rules for weekly / monthly / yearly reviews.
    * Threshold semantics (e.g., “≥ N similar incidents in window_days”).

All pattern windows, thresholds and review frequencies in this document must be compatible with the cyclic definitions in Doc 8 and the profiles in Doc 7.

### 1.4 Orgo v3 Insights Tech Stack Baseline

The Insights module uses a **Python + Airflow + Postgres + Redis** stack dedicated to analytics. Core Orgo services may run on a different stack (e.g., NestJS + Prisma + Next.js + RTK Query + Postgres); that separation is intentional.

| Aspect                  | Orgo v3 Insights Baseline                          | Notes                                                                                     |
| ----------------------- | -------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| Analytics runtime       | Python **3.11.6**                                  | Used by ETL workers and analytics services.                                               |
| Orchestration           | Apache Airflow **2.8.x**                           | Manages ETL DAGs and pattern detection jobs.                                              |
| Warehouse / DB          | PostgreSQL **15.x**                                | Same major version as core DB; may be a separate instance or host the `insights` schema.  |
| Cache                   | Redis **7.x**                                      | Used for report result caching and dashboard pre‑computation.                             |
| Reporting API (logical) | `reports-api` (read‑only service over star schema) | Implementation and code mapping described in Doc 4; this document constrains config only. |

Clarifications:

* **Core DB**: Doc 1/5 designate Postgres 15+ as the core OLTP engine; Insights uses Postgres 15+ for the analytics star schema (`insights.*`).
* **Redis & Airflow** in this document are **analytics‑specific components**. Core services may use Redis for other caching or queues, but the parameters here govern **only** the Insights use cases.

---

## 2. Configuration Parameters and Invariants

This section defines the main operational parameters for the Insights module, grouped by concern. These values are applied per‑environment as described in §2.6.

### 2.1 Data Retention and Purge (Analytics Layer)

These parameters apply to **analytics storage**, not to operational task/case tables. Profiles in Doc 7 may have their own `data_retention_policy`; that governs **operational** data, not necessarily analytics copies.

* **`analytics.raw_event_retention_days`**

  * Definition: Number of days to retain raw events in the base fact tables in the `insights` schema (e.g. `insights.fact_tasks`, `insights.fact_cases`, `insights.fact_wellbeing_checkins`).
  * Defaults:

    * `dev`: 730
    * `staging`: 730
    * `prod`: 730
  * Invariants:

    * Must be **≥ max** of all pattern windows defined in `insights.patterns.*.window_days` (§3.2).
    * Does **not** need to be ≥ all profile‑level retention values; analytics can keep a subset of long‑term history if storage is constrained.

* **`analytics.aggregated_retention_days`**

  * Definition: Days to retain aggregated snapshots and materialized views (e.g., monthly summary tables).
  * Defaults:

    * `dev`: 90
    * `staging`: 730
    * `prod`: 3650 (10 years)
  * Invariants:

    * Must be ≥ `analytics.raw_event_retention_days` for any aggregate that depends only on those events.
    * Large aggregates may be down‑sampled (e.g., yearly rollups) without violating profile‑level `data_retention_policy`.

* **`analytics.pattern_result_retention_days`**

  * Definition: Days to retain computed pattern records (pattern tables and pattern snapshot tables produced by cyclic overview jobs).
  * Defaults:

    * `dev`: 90
    * `staging`: 730
    * `prod`: 1825 (5 years)
  * Invariants:

    * Must be ≥ the longest review horizon in Doc 8 (yearly systemic review).

### 2.2 Backup and Recovery Policies

These parameters govern the analytics warehouse and ETL metadata (Airflow database). They are independent of core DB backup policies.

* **`analytics.backup.rpo_minutes`**

  * Definition: Recovery Point Objective for analytics data (maximum acceptable data loss).
  * Defaults:

    * `dev`: 1440 (daily backup)
    * `staging`: 60
    * `prod`: 15
  * Invariants:

    * Must be ≤ the shortest cyclic overview window used for critical compliance patterns.

* **`analytics.backup.rto_minutes`**

  * Definition: Recovery Time Objective for analytics services.
  * Defaults:

    * `dev`: 1440 (best effort)
    * `staging`: 240
    * `prod`: 60

*Backup strategy (descriptive)*

* Warehouse backups:

  * Nightly full backup for `staging` and `prod`.
  * Hourly WAL/LSN‑based incremental for `prod`.
* Airflow metadata:

  * Snapshot at least daily in `staging`, every 4 hours in `prod`.
* Offline / `offline` environment:

  * No automatic backups; manual exports only.

### 2.3 Cache TTLs and Aggregation Windows

These parameters drive Redis caching and derived aggregation behaviour.

* **`analytics.cache.ttl_seconds.dashboard_default`**

  * Definition: Default cache TTL for dashboard queries in `reports-api`.
  * Default: `300` seconds (5 minutes) in all environments.
  * Invariants:

    * `reports-api` must use this as its default TTL for non‑streaming endpoints.

* **`analytics.cache.ttl_seconds.dashboard_slow`**

  * Definition: TTL for expensive aggregated dashboards.
  * Defaults:

    * `dev`: 60
    * `staging`: 600
    * `prod`: 900

* **`analytics.cache.ttl_seconds.streaming_like`**

  * Definition: TTL for endpoints that mimic near‑real‑time behaviour (if any).
  * Default: `30` seconds.

* **`analytics.cache.max_keys_per_dashboard`**

  * Definition: Upper bound on the number of distinct cache keys per dashboard per environment.
  * Defaults:

    * `dev`: 100
    * `staging`: 1_000
    * `prod`: 5_000

### 2.4 Export Limits and Privacy Safeguards

These parameters guard against over‑large exports and enforce privacy requirements.

* **`analytics.export.max_rows_per_export`**

  * `dev`: 100_000
  * `staging`: 100_000
  * `prod`: 50_000

* **`analytics.export.max_parallel_exports_per_user`**

  * `dev`: 5
  * `staging`: 3
  * `prod`: 2

* **`analytics.export.pii_masking_enabled`**

  * Boolean, default `true` for all environments.
  * Semantics:

    * When `true`, the reporting layer masks or hashes columns designated as PII by the schemas and guardrails in Doc 1/Doc 2 (and any dedicated security/privacy documentation).
    * The masking rules must be compatible with `VISIBILITY` semantics in Doc 2 and case/task metadata visibility in Doc 8.

* **`analytics.export.allowed_visibilities`**

  * Array of `VISIBILITY` values allowed to appear in exports:

    * Default: `["PUBLIC", "INTERNAL"]`.
  * Tasks/cases with `RESTRICTED` or `ANONYMISED` visibility may only be exported in aggregated or anonymised form.

### 2.5 Access Control and Routing Invariants

These rules define how visibility, roles and profiles interact in the analytics slice.

* `analytics.access.public_roles` – roles allowed to see **PUBLIC** analytics.
* `analytics.access.internal_roles` – roles allowed to see **INTERNAL** analytics.
* `analytics.access.restricted_roles` – roles allowed to see **RESTRICTED** analytics.
* `analytics.access.anonymised_roles` – roles allowed to see fully anonymised pattern outputs even from sensitive domains.

Invariants:

* For any given dashboard:

  * The minimum required `VISIBILITY` for every underlying task/case determines the minimum role required to view that dashboard.
* Access rules must be **consistent** with:

  * Case access control in Doc 8.
  * Role definitions and RBAC/guardrails in Doc 2 and the Core Services/security specs (Doc 5 and any dedicated security documentation).

### 2.6 Environment‑Specific Defaults Overview

For quick reference, the main environment‑dependent values from §§2.1–2.4 are summarized here:

* **`ENVIRONMENT = "dev"`**

  * Small data volumes, rapid schema evolution.
  * `analytics.raw_event_retention_days = 730`
  * `analytics.aggregated_retention_days = 90`
  * `analytics.pattern_result_retention_days = 90`
  * `analytics.backup.rpo_minutes = 1440`
  * `analytics.backup.rto_minutes = 1440`
  * `analytics.export.max_rows_per_export = 100_000`

* **`ENVIRONMENT = "staging"`**

  * Near‑prod realistic loads.
  * `analytics.raw_event_retention_days = 730`
  * `analytics.aggregated_retention_days = 730`
  * `analytics.pattern_result_retention_days = 730`
  * `analytics.backup.rpo_minutes = 60`
  * `analytics.backup.rto_minutes = 240`
  * `analytics.export.max_rows_per_export = 100_000`

* **`ENVIRONMENT = "prod"`**

  * Authoritative analytics environment.
  * `analytics.raw_event_retention_days = 730`
  * `analytics.aggregated_retention_days = 3650`
  * `analytics.pattern_result_retention_days = 1825`
  * `analytics.backup.rpo_minutes = 15`
  * `analytics.backup.rto_minutes = 60`
  * `analytics.export.max_rows_per_export = 50_000`

* **`ENVIRONMENT = "offline"`**

  * Used when analytics jobs must run in a disconnected environment.
  * No automated backups; ETL and exports may be disabled or run only on manually imported snapshots.

Doc 2 remains the canonical reference for allowed environment names; this section only provides module‑specific default values.

---

## 3. Insights Config Schema

This section defines a machine‑readable schema for Insights configuration, typically serialized as YAML in e.g. `/config/insights/config.yaml`.

All general config expectations (metadata, validation, per‑environment handling) are defined in Doc 2; this section defines the **`insights:`** subtree.

### 3.1 Top‑Level Structure

```yaml
insights:
  environment: "prod"             # must be one of: dev, staging, prod, offline

  warehouse:
    type: "postgres"              # "postgres" | "bigquery" | "snowflake"
    connection_url: "${INSIGHTS_WAREHOUSE_URL}"
    schema: "insights"
    read_only_user: "orgo_insights_ro"
    write_user: "orgo_insights_etl"

  etl:
    owner_email: "data-team@example.org"
    default_batch_size: 1000
    max_batch_size: 10000
    concurrency: 4

  cache:
    backend: "redis"
    url: "${INSIGHTS_REDIS_URL}"
    ttl_seconds:
      dashboard_default: 300
      dashboard_slow: 900
      streaming_like: 30
    max_keys_per_dashboard:
      dev: 100
      staging: 1000
      prod: 5000

  retention:
    raw_event_retention_days:
      dev: 730
      staging: 730
      prod: 730
    aggregated_retention_days:
      dev: 90
      staging: 730
      prod: 3650
    pattern_result_retention_days:
      dev: 90
      staging: 730
      prod: 1825

  backups:
    rpo_minutes:
      dev: 1440
      staging: 60
      prod: 15
    rto_minutes:
      dev: 1440
      staging: 240
      prod: 60

  exports:
    max_rows_per_export:
      dev: 100000
      staging: 100000
      prod: 50000
    max_parallel_exports_per_user:
      dev: 5
      staging: 3
      prod: 2
    pii_masking_enabled: true
    allowed_visibilities:
      - "PUBLIC"
      - "INTERNAL"

  patterns:
    default_profile_key: "default"   # must exist in Doc 7 profiles
    overrides_by_domain:
      maintenance: "hospital"
      hr_case: "advocacy_group"
      education_support: "retail_chain"
    weekly:
      window_days: 28
      min_events: 3
      min_distinct_sources: 1
    monthly:
      window_days: 180
      min_events: 5
      min_distinct_sources: 2
    yearly:
      window_days: 730
      min_events: 10
      min_distinct_sources: 3
    # Keys under `overrides_by_domain` MUST match canonical Task.type values
    # (for example: "maintenance", "hr_case", "education_support"), not arbitrary labels.


```

Notes:

* `insights.environment` must match both:

  * The `INSIGHTS_ENV` environment variable, and
  * One of the canonical `ENVIRONMENT` values from Doc 2.

* `warehouse.schema` is set to `"insights"` to match the canonical star schema in Doc 1; when an external warehouse is used, this schema may be mirrored there.

### 3.2 Profiles and Pattern Settings

* `default_profile_key` and values under `overrides_by_domain` must correspond to profile keys defined in Doc 7 (e.g. `friend_group`, `hospital`, `advocacy_group`, `retail_chain`, etc.).
* The value used in `default_profile_key` (e.g. `"default"`) **must** be defined as a real profile entry in the profiles YAML (Doc 7) alongside the other named profiles.
* Each profile defines (see Doc 2/7):

  * Reactivity time.
  * Transparency.
  * Escalation granularity.
  * Review frequency.
  * Notification scope.
  * Pattern sensitivity.
  * Severity escalation threshold.
  * Logging and traceability depth.
  * Data retention policy.

Relationship between profiles and Insights config:

* **Profiles** describe **behavioural expectations** and default metadata at the operational level.
* **Insights config** describes **how much data** is kept, how often analytics run, and which profile is used by default per domain.

If a profile includes a long `data_retention_policy` (e.g. hospital = 10 years) while `analytics.raw_event_retention_days` is shorter, analytics will not capture the full operational horizon but must, at minimum, retain data long enough to satisfy the cyclic pattern windows from Doc 8.

---

## 4. ETL and Airflow Job Configuration

This section defines the DAGs that populate the `insights.*` schema and compute patterns.

### 4.1 DAG Inventory (YAML‑Style)

```yaml
etl_dags:

  daily_events_load:
    id: "insights_daily_events_load"
    schedule: "0 2 * * *"   # daily at 02:00 UTC
    description: "Load operational tasks/cases into the insights fact tables (insights.fact_tasks, insights.fact_cases, insights.fact_wellbeing_checkins, etc.)"
    enabled_environments: ["staging", "prod"]
	queue_job_id: "orgo.analytics.export-facts"

  daily_dimensions_sync:
    id: "insights_daily_dimensions_sync"
    schedule: "30 2 * * *"
    description: "Sync dimension tables (organizations, roles, labels) into insights.dim_*"
    enabled_environments: ["staging", "prod"]
	queue_job_id: "orgo.analytics.export-facts"

  weekly_pattern_review:
    id: "insights_weekly_pattern_review"
    schedule: "0 3 * * 1"   # every Monday at 03:00 UTC
    description: "Compute weekly patterns based on patterns.weekly.window_days"
    enabled_environments: ["staging", "prod"]
	queue_job_id: "orgo.insights.weekly-pattern-review"

  monthly_trend_report:
    id: "insights_monthly_trend_report"
    schedule: "0 4 1 * *"   # first of each month
    description: "Generate monthly trend aggregates and store in summary tables / materialized views"
    enabled_environments: ["staging", "prod"]
	queue_job_id: "orgo.insights.monthly-trend-report"

  yearly_systemic_review:
    id: "insights_yearly_systemic_review"
    schedule: "0 5 1 1 *"   # January 1st
    description: "Compute yearly systemic patterns used by leadership overviews"
    enabled_environments: ["prod"]
	queue_job_id: "orgo.insights.yearly-systemic-review"

  cache_warmup_dashboards:
    id: "insights_cache_warmup_dashboards"
    schedule: "*/15 * * * *"  # every 15 minutes
    description: "Pre‑warm caches for high‑traffic dashboards"
    enabled_environments: ["staging", "prod"]
	queue_job_id: "orgo.insights.cache-warmup-dashboards"
```

### 4.2 Job‑Level Constraints and Invariants

* `weekly_pattern_review`:

  * Must use `patterns.weekly.window_days` from §3.1 and cyclic review semantics from Doc 8.
* `monthly_trend_report` and `yearly_systemic_review`:

  * Must derive thresholds and labels in a way compatible with the labels and categorization rules in Doc 8.
* All ETL DAGs:

  * Must treat `ENVIRONMENT = "offline"` as **no‑op**, unless explicitly enabled in offline deployments.
  * Must not mutate operational tables; they are read‑only consumers of the canonical Task and Case models.

---

## 5. Environment Variables and Secrets

These are the primary configuration variables for the Insights module. Values come from environment variables, secret managers (e.g., Vault, KMS) or config maps.

| Environment Variable              | Used By                       | Default / Example                      | Source & Notes                                                                               |
| --------------------------------- | ----------------------------- | -------------------------------------- | -------------------------------------------------------------------------------------------- |
| `INSIGHTS_ENV`                    | All insights components       | `dev` / `staging` / `prod` / `offline` | Must match `ENVIRONMENT` enum; used to select per‑environment defaults.                      |
| `INSIGHTS_WAREHOUSE_URL`          | ETL workers, `reports-api`    | `postgresql://.../orgo_analytics`      | Stored in secret manager; must point at the DB/warehouse hosting the `insights` star schema. |
| `INSIGHTS_REDIS_URL`              | `reports-api`, cache warmers  | `redis://redis:6379/1`                 | May share Redis instance with core, but uses separate DB/namespace.                          |
| `AIRFLOW__CORE__SQL_ALCHEMY_CONN` | Airflow scheduler & webserver | `postgresql+psycopg2://.../airflow`    | Airflow’s internal metadata DB.                                                              |
| `AIRFLOW__CORE__FERNET_KEY`       | Airflow                       | Random 32‑byte base64 key              | Key rotation rules defined in security/DevOps docs; secrets‑backed in prod.                  |
| `INSIGHTS_DEFAULT_PROFILE_KEY`    | `reports-api`, ETL            | `default`                              | Must match a profile in Doc 7; fallback when no domain override applies.                     |
| `INSIGHTS_PATTERN_CONFIG_PATH`    | ETL, pattern DAGs             | `/config/insights/patterns.yaml`       | Optional override for pattern thresholds; must respect schema in §3.1–3.2.                   |
| `INSIGHTS_EXPORT_S3_BUCKET`       | Export workers (if used)      | `orgo-insights-exports-prod`           | Required only when exports are stored in object storage.                                     |

Additional environment variables and secrets for monitoring and logging are covered in the core infrastructure / monitoring / security documentation (e.g. Docs 4–5 and any dedicated ops or security specs) and must be consistent with the base infrastructure configuration.

---

## 6. Deployment, Scaling and Monitoring (Insights Slice)

### 6.1 Runtime Components

Typical components (Kubernetes or equivalent):

* `reports-api` deployment
* `insights-etl-worker` deployment(s)
* `airflow-webserver`, `airflow-scheduler`, `airflow-worker` deployments
* `analytics-db` (Postgres 15.x) hosting the `insights.*` star schema, or a logical `insights` schema within the core Postgres instance
* `insights-redis` (Redis 7.x) cache

Recommended prod baseline:

| Component             | Replicas (prod) | CPU (req/limit) | RAM (req/limit) | Notes                                                 |
| --------------------- | --------------- | --------------- | --------------- | ----------------------------------------------------- |
| `reports-api`         | 3–8             | 250m / 1000m    | 512Mi / 2Gi     | HPA on CPU + request latency.                         |
| `insights-etl-worker` | 2–4             | 500m / 2000m    | 1Gi / 4Gi       | Scales with ETL backlog and DAG durations.            |
| `airflow-scheduler`   | 1               | 250m / 500m     | 512Mi / 1Gi     | Usually single instance.                              |
| `airflow-webserver`   | 1–2             | 250m / 500m     | 512Mi / 1Gi     | Primarily operator UI.                                |
| `airflow-worker`      | 2–6             | 500m / 2000m    | 1Gi / 4Gi       | Scales with number and duration of running tasks.     |
| `insights-redis`      | 1–3 (cluster)   | 250m / 1000m    | 512Mi / 2Gi     | May be a shared Redis cluster with logical isolation. |

### 6.2 Scaling Policies

Example HPA rules:

* `reports-api`:

  * Target: P95 latency ≤ 1000 ms, error rate ≤ 1%.
  * Scale out when CPU > 70% or P95 latency > 1000 ms for 5 minutes.
* `insights-etl-worker`:

  * Scale based on:

    * Number of runnable tasks in Airflow.
    * ETL job delay vs schedule (lag metrics defined below).

### 6.3 Monitoring and Alerts

Key Prometheus/Grafana metrics:

* `insights_etl_dag_failures_total{dag_id=...}`
* `insights_etl_dag_delay_minutes{dag_id=...}`
* `reports_api_request_duration_seconds{quantile="0.95"}`
* `reports_api_error_rate`
* `insights_redis_cache_hit_ratio`
* `analytics_db_cpu_usage`, `analytics_db_connections`

Suggested alerts:

* **ETL Failure**:

  * Condition: `insights_etl_dag_failures_total` increases for any critical DAG.
  * Action: Page on‑call data engineer; re‑run failed DAG if safe.

* **ETL Delay**:

  * Condition: `insights_etl_dag_delay_minutes > 60` for `daily_events_load` in `prod`.
  * Action: Investigate source system health, DB performance, and worker capacity.

* **Reporting Latency**:

  * Condition: `reports_api_request_duration_seconds{quantile="0.95"} > 1.0` for 10 min.
  * Action: Trigger autoscale and inspect slow queries.

* **Cache Hit Ratio Low**:

  * Condition: `insights_redis_cache_hit_ratio < 0.7` for 30 min.
  * Action: Review cache key strategy and TTLs in §2.3.

---

## 7. Cross‑Document Alignment Notes

This section encodes explicitly the alignment guidance so the document is self‑contained.

### 7.1 Tech Stack Alignment

* Insights uses **Python 3.11.6 + Airflow 2.8 + Postgres 15 + Redis 7** (§1.4).
* Core Orgo may use another stack (e.g., NestJS/Next.js/Prisma/Postgres) as defined in Docs 3–5.
* Postgres 15+ is common across both:

  * Core OLTP tables (Doc 1).
  * Analytics star schema (`insights.*` in Doc 1, Module 14 – Analytics / Insights Star‑Schema).
* Redis and Airflow parameters in this document apply **only to the Insights module** unless Doc 5 explicitly states shared usage.

### 7.2 Enum Consistency

* `TASK_STATUS`, `TASK_PRIORITY`, `TASK_SEVERITY`, `VISIBILITY` and `ENVIRONMENT` values in §1.2 are **exactly the same** as in Doc 2.
* If Doc 2 is updated (e.g. a new status or visibility value), §1.2 and any analytics DDL that depends on these enums must be updated in lockstep.

### 7.3 Profiles vs Config

* Profiles (Doc 7) define **behavioural defaults** (reactivity, transparency, pattern sensitivity, logging, data retention).
* Insights config (this document) defines **technical parameters**:

  * How long analytics data is stored.
  * When and how often pattern detection runs.
  * Export and cache limits.
* Where parameters need to align:

  * Pattern windows (`patterns.weekly/monthly/yearly.window_days`) must be consistent with Doc 8’s cyclic review semantics.
  * Profile‑level `log_retention_days` or `data_retention_policy` may be longer than analytics warehouse retention. This is allowed, but analytics retention must always be ≥ the maximum pattern window.

### 7.4 Environment‑Specific Defaults and Global ENVIRONMENT

* `ENVIRONMENT` is globally defined and constrained in Doc 2 as `"dev"`, `"staging"`, `"prod"`, `"offline"`.
* This document shows how **Insights** uses those values to select retention, backup, cache and export defaults (§2.6).
* Other modules may:

  * Use the same environments without per‑environment variation (e.g., core services with mostly static config).
  * Or define their own environment‑specific defaults (e.g., Core Services in Doc 5).
* The important invariant is that **every module interprets environment names consistently**, but parameter values per environment can differ by module; this document captures the Insights slice.

===== END 6-orgo-insights-module-config-parameters.md (#0006) =====

===== BEGIN 7-orgo-organization-profiles-and-cyclic-overview.md (#0007) =====
﻿<!-- INDEX: Doc 7 – Organization Profiles & Behavioural Archetypes (profiles YAML) (Use YAML comments only so the file stays valid.) -->
INDEX
1. _template – Schema template (reference only)
2. default – Balanced default organizational profile
3. friend_group – Low‑stakes social group
4. hospital – Clinical / hospital environment (safety‑critical)
5. advocacy_group – Advocacy / human‑rights NGO
6. retail_chain – Distributed retail / franchise operations
7. military_organization – Highly sensitive, fully audited environment
8. environmental_group – Environmental / climate organization
9. artist_collective – Creative collective, relaxed timing



profiles:
  # ---------------------------------------------------------------------------
  # SCHEMA TEMPLATE (REFERENCE ONLY)
  # ---------------------------------------------------------------------------
  _template:
    description: "Template profile – do not use directly, copy and override."

    # --- File-level metadata for this profile (per your config checklist) ---
    metadata:
      version: "3.0"
      last_updated: "2025-11-19"
      environment: "prod"               # dev | staging | prod | offline

    # 1. Reactivity / Escalation timing
    reactivity_seconds: 0               # base time before first escalation (in seconds)
    max_escalation_seconds: 0           # hard cap until issue must reach top (in seconds)

    # 2. Information visibility
    # JSON values map to canonical VISIBILITY enum:
    #   public      -> PUBLIC
    #   internal    -> INTERNAL
    #   restricted  -> RESTRICTED
    #   anonymised  -> ANONYMISED
    transparency_level: balanced        # full | balanced | restricted | private

    # 3. Escalation structure
    escalation_granularity: moderate    # relaxed | moderate | detailed | aggressive

    # 4. Review cadence
    review_frequency: monthly           # real_time | daily | weekly | monthly | quarterly | yearly | ad_hoc

    # 5. Who gets notified
    notification_scope: department      # user | team | department | org_wide

    # 6. Pattern detection
    pattern_sensitivity: medium         # low | medium | high | critical
    pattern_window_days: 30             # time window for pattern counting
    pattern_min_events: 3               # min similar events to trigger pattern

    # 7. Severity / auto‑escalation
    # severity_threshold is a coarse “how sensitive” knob:
    #   very_high = only the worst issues escalate fast
    #   high      = major+ escalate fast
    #   medium    = major+ and some moderate escalate fast
    #   low       = even minor issues escalate fast
    severity_threshold: medium          # very_high | high | medium | low

    severity_policy:
      critical:
        immediate_escalation: true
      major:
        immediate_escalation: true
      minor:
        immediate_escalation: false

    # 8. Logging & traceability
    logging_level: standard             # minimal | standard | detailed | audit
    log_retention_days: 365             # days logs (and operational records) are kept

    # 9. Automation level
    automation_level: medium            # manual | low | medium | high | full

    # 10. Defaults for task metadata
    # JSON values map to canonical enums:
    #   default_priority: low|medium|high|critical -> TASK_PRIORITY
    #   visibility: public|internal|restricted|anonymised -> VISIBILITY
    default_task_metadata:
      visibility: internal              # public | internal | restricted | anonymised
      default_priority: medium          # low | medium | high | critical
      default_reactivity_seconds: 86400 # default SLA for tasks created under this profile

    # 11. Cyclic Overview (periodic pattern reviews & triggers)
    cyclic_overview:
      enabled: true
      schedule:
        weekly: false
        monthly: true
        yearly: true
      threshold_triggers:
        incident_frequency:
          min_events: 3
          window_days: 30
        cross_departmental_trends: false
        high_risk_indicators: false

  # ---------------------------------------------------------------------------
  # DEFAULT PROFILE
  # Balanced org-wide defaults when nothing more specific is selected
  # ---------------------------------------------------------------------------
  default:
    description: "Default balanced organizational profile used when no more specific archetype is selected."
    metadata:
      version: "3.0"
      last_updated: "2025-11-19"
      environment: "prod"

    # Reactivity: moderate (12–24h)
    reactivity_seconds: 43200           # 12 hours
    max_escalation_seconds: 172800      # 48 hours

    transparency_level: balanced
    escalation_granularity: moderate
    review_frequency: monthly
    notification_scope: department      # canonical enum value

    pattern_sensitivity: medium
    pattern_window_days: 30
    pattern_min_events: 3

    severity_threshold: medium
    severity_policy:
      critical:
        immediate_escalation: true
      major:
        immediate_escalation: true
      minor:
        immediate_escalation: false

    logging_level: standard
    log_retention_days: 1095            # ~3 years

    automation_level: medium

    default_task_metadata:
      visibility: internal
      default_priority: medium
      default_reactivity_seconds: 43200

    cyclic_overview:
      enabled: true
      schedule:
        weekly: true
        monthly: true
        yearly: true
      threshold_triggers:
        incident_frequency:
          min_events: 3
          window_days: 30
        cross_departmental_trends: true
        high_risk_indicators: true

  # ---------------------------------------------------------------------------
  # 1. FRIEND GROUP
  # Low‑stakes social group, almost everything transparent, low urgency
  # ---------------------------------------------------------------------------
  friend_group:
    description: "Small, low‑stakes social group; almost everything is transparent; escalation over days or weeks."
    metadata:
      version: "3.0"
      last_updated: "2025-11-19"
      environment: "prod"

    # Reactivity: relaxed (days)
    reactivity_seconds: 259200          # 3 days before first escalation
    max_escalation_seconds: 1814400     # 21 days to reach top level

    # Transparency: fully transparent to members
    transparency_level: full            # everyone in the group can see updates

    # Escalation structure: detailed (but slow)
    escalation_granularity: detailed    # all intermediate levels exist but move slowly

    # Reviews: rare / ad‑hoc
    review_frequency: ad_hoc            # explicit annual or ad‑hoc reviews only

    # Notification scope: small team
    notification_scope: team            # only people directly involved / mentioned

    # Patterns: only very persistent patterns matter
    pattern_sensitivity: low
    pattern_window_days: 90             # look over 3 months
    pattern_min_events: 5               # need at least 5 similar events

    # Severity: only very serious issues escalate fast
    severity_threshold: very_high
    severity_policy:
      critical:
        immediate_escalation: true
      major:
        immediate_escalation: false
      minor:
        immediate_escalation: false

    # Logging: very lightweight; short retention
    logging_level: minimal
    log_retention_days: 180             # ~6 months, matches “3–6 months” retention

    # Automation: mostly manual
    automation_level: manual

    # Default metadata for tasks created under this profile
    default_task_metadata:
      visibility: public                # visible to the whole group
      default_priority: low
      default_reactivity_seconds: 259200

    # Cyclic Overview
    cyclic_overview:
      enabled: true
      schedule:
        weekly: false
        monthly: true
        yearly: true
      threshold_triggers:
        incident_frequency:
          min_events: 5
          window_days: 90
        cross_departmental_trends: false
        high_risk_indicators: false

  # ---------------------------------------------------------------------------
  # 2. HOSPITAL
  # High‑stakes, safety‑critical environment, strong audit and long retention
  # ---------------------------------------------------------------------------
  hospital:
    description: "Clinical / hospital environment: life‑critical, rapid escalation, strong privacy, full audit trail."
    metadata:
      version: "3.0"
      last_updated: "2025-11-19"
      environment: "prod"

    # Reactivity: immediate (minutes)
    reactivity_seconds: 300             # 5 minutes to first escalation
    max_escalation_seconds: 3600        # 1 hour to reach top escalation

    # Transparency: moderately private (only key teams)
    transparency_level: restricted      # visible to designated clinical / ops roles

    # Escalation structure: accelerated / aggressive
    escalation_granularity: aggressive  # skips intermediate levels when needed

    # Reviews: continuous / real‑time
    review_frequency: real_time         # operational reviews happen continuously

    # Notification scope: focused small team
    notification_scope: team            # on‑call clinical / safety team

    # Patterns: highly sensitive
    pattern_sensitivity: high
    pattern_window_days: 7              # last week of events
    pattern_min_events: 2               # 2 similar incidents trigger pattern alert

    # Severity: low threshold – even minor issues escalate quickly
    severity_threshold: low
    severity_policy:
      critical:
        immediate_escalation: true
      major:
        immediate_escalation: true
      minor:
        immediate_escalation: false     # escalated fast, but not “immediate”

    # Logging: full audit trail and long retention
    logging_level: audit
    log_retention_days: 3650            # ~10 years, regulatory/audit needs

    # Automation: high (but still supervised)
    automation_level: high

    # Default metadata
    default_task_metadata:
      visibility: restricted            # minimal set of roles
      default_priority: high
      default_reactivity_seconds: 300

    # Cyclic Overview
    cyclic_overview:
      enabled: true
      schedule:
        weekly: true
        monthly: true
        yearly: true
      threshold_triggers:
        incident_frequency:
          min_events: 2
          window_days: 7
        cross_departmental_trends: true
        high_risk_indicators: true

  # ---------------------------------------------------------------------------
  # 3. ADVOCACY GROUP
  # Mission‑driven NGO; responsive but not as extreme as hospitals
  # ---------------------------------------------------------------------------
  advocacy_group:
    description: "Advocacy / human‑rights NGO: responsive within 12–24h, balanced transparency, strong but not extreme traceability."
    metadata:
      version: "3.0"
      last_updated: "2025-11-19"
      environment: "prod"

    # Reactivity: responsive (12–24h)
    reactivity_seconds: 43200           # 12 hours to first escalation
    max_escalation_seconds: 172800      # 48 hours to reach top

    # Transparency: moderately transparent
    transparency_level: balanced        # visible to relevant teams + leadership

    # Escalation structure: moderate
    escalation_granularity: moderate

    # Reviews: frequent (weekly)
    review_frequency: weekly

    # Notification scope: departmental
    notification_scope: department      # campaign / program team + leadership

    # Patterns: balanced sensitivity
    pattern_sensitivity: medium
    pattern_window_days: 30             # last month
    pattern_min_events: 3               # 3 similar events trigger pattern

    # Severity: balanced threshold
    severity_threshold: medium
    severity_policy:
      critical:
        immediate_escalation: true
      major:
        immediate_escalation: true
      minor:
        immediate_escalation: false

    # Logging: standard, moderate retention
    logging_level: standard
    log_retention_days: 1095            # ~3 years (within 1–5 year band)

    # Automation: moderate, human oversight
    automation_level: medium

    # Defaults
    default_task_metadata:
      visibility: internal
      default_priority: medium
      default_reactivity_seconds: 43200

    # Cyclic Overview
    cyclic_overview:
      enabled: true
      schedule:
        weekly: true
        monthly: true
        yearly: true
      threshold_triggers:
        incident_frequency:
          min_events: 3
          window_days: 30
        cross_departmental_trends: true
        high_risk_indicators: true

  # ---------------------------------------------------------------------------
  # 4. RETAIL CHAIN
  # Distributed stores, operational focus, balanced cost vs. oversight
  # ---------------------------------------------------------------------------
  retail_chain:
    description: "Multi‑store retail / franchise: 24–72h SLA, focus on incidents and operations, moderate automation and logging."
    metadata:
      version: "3.0"
      last_updated: "2025-11-19"
      environment: "prod"

    # Reactivity: 24–72h
    reactivity_seconds: 86400           # 24 hours to first escalation
    max_escalation_seconds: 259200      # 72 hours to reach top

    # Transparency: balanced
    transparency_level: balanced        # store + area manager + HQ ops

    # Escalation structure: moderate
    escalation_granularity: moderate

    # Reviews: monthly
    review_frequency: monthly

    # Notification scope: departmental (store + ops)
    notification_scope: department

    # Patterns: moderate sensitivity
    pattern_sensitivity: medium
    pattern_window_days: 60             # last 2 months
    pattern_min_events: 4               # 4 similar cases needed for pattern

    # Severity: high threshold (only severe issues immediate)
    severity_threshold: high
    severity_policy:
      critical:
        immediate_escalation: true
      major:
        immediate_escalation: true
      minor:
        immediate_escalation: false

    # Logging: standard, medium‑term retention
    logging_level: standard
    log_retention_days: 1825            # ~5 years

    # Automation: moderate
    automation_level: medium

    # Defaults
    default_task_metadata:
      visibility: internal
      default_priority: medium
      default_reactivity_seconds: 86400

    # Cyclic Overview
    cyclic_overview:
      enabled: true
      schedule:
        weekly: false
        monthly: true
        yearly: true
      threshold_triggers:
        incident_frequency:
          min_events: 4
          window_days: 60
        cross_departmental_trends: true
        high_risk_indicators: false

  # ---------------------------------------------------------------------------
  # 5. MILITARY ORGANIZATION
  # Extremely sensitive, private, fully automated, long/indefinite retention
  # ---------------------------------------------------------------------------
  military_organization:
    description: "Military / defense environment: immediate escalation, highly private, full automation and long‑term retention."
    metadata:
      version: "3.0"
      last_updated: "2025-11-19"
      environment: "prod"

    # Reactivity: immediate (minutes)
    reactivity_seconds: 120             # 2 minutes to first escalation
    max_escalation_seconds: 900         # 15 minutes to reach top

    # Transparency: highly private
    transparency_level: private         # only explicitly authorized roles

    # Escalation structure: broad/aggressive
    escalation_granularity: aggressive  # jumps quickly to higher levels

    # Reviews: continuous / real time
    review_frequency: real_time

    # Notification scope: very small team (ops / command)
    notification_scope: team

    # Patterns: immediate, very high sensitivity
    pattern_sensitivity: critical
    pattern_window_days: 7              # any 7‑day window
    pattern_min_events: 2               # 1–2 incidents acceptable; we use 2

    # Severity: effectively no threshold – everything escalates quickly
    severity_threshold: low
    severity_policy:
      critical:
        immediate_escalation: true
      major:
        immediate_escalation: true
      minor:
        immediate_escalation: true

    # Logging: full audit, effectively indefinite retention
    logging_level: audit
    log_retention_days: 36500           # ~100 years (effectively “indefinite”)

    # Automation: fully automated, with human override
    automation_level: full

    # Defaults
    default_task_metadata:
      visibility: restricted            # tightly scoped, non‑public
      default_priority: high
      default_reactivity_seconds: 120

    # Cyclic Overview
    cyclic_overview:
      enabled: true
      schedule:
        weekly: true
        monthly: true
        yearly: true
      threshold_triggers:
        incident_frequency:
          min_events: 2
          window_days: 7
        cross_departmental_trends: true
        high_risk_indicators: true

  # ---------------------------------------------------------------------------
  # 6. ENVIRONMENTAL GROUP
  # Campaign‑driven organization, high pattern sensitivity, org‑wide signalling
  # ---------------------------------------------------------------------------
  environmental_group:
    description: "Environmental / climate organization: high pattern sensitivity, org‑wide signalling, balanced oversight."
    metadata:
      version: "3.0"
      last_updated: "2025-11-19"
      environment: "prod"

    # Reactivity: responsive (12–24h)
    reactivity_seconds: 43200           # 12 hours
    max_escalation_seconds: 172800      # 48 hours

    # Transparency: moderately transparent
    transparency_level: balanced        # visible to relevant teams across org

    # Escalation: moderate
    escalation_granularity: moderate

    # Reviews: frequent (weekly / bi‑weekly)
    review_frequency: weekly

    # Notification scope: org‑wide for key events
    notification_scope: org_wide

    # Patterns: high sensitivity (campaigns, repeated abuses)
    pattern_sensitivity: high
    pattern_window_days: 30             # last month
    pattern_min_events: 3

    # Severity: balanced threshold
    severity_threshold: medium
    severity_policy:
      critical:
        immediate_escalation: true
      major:
        immediate_escalation: true
      minor:
        immediate_escalation: false

    # Logging: standard, moderate‑term retention
    logging_level: standard
    log_retention_days: 1825            # ~5 years

    # Automation: moderate, to assist volunteers/staff
    automation_level: medium

    # Defaults
    default_task_metadata:
      visibility: internal
      default_priority: medium
      default_reactivity_seconds: 43200

    # Cyclic Overview
    cyclic_overview:
      enabled: true
      schedule:
        weekly: true
        monthly: true
        yearly: true
      threshold_triggers:
        incident_frequency:
          min_events: 3
          window_days: 30
        cross_departmental_trends: true
        high_risk_indicators: true

  # ---------------------------------------------------------------------------
  # 7. ARTIST COLLECTIVE
  # Creative group; low stakes, relaxed timing, minimal logging
  # ---------------------------------------------------------------------------
  artist_collective:
    description: "Artist / creative collective: relaxed deadlines, balanced transparency within the group, minimal logging."
    metadata:
      version: "3.0"
      last_updated: "2025-11-19"
      environment: "prod"

    # Reactivity: relaxed (days/weeks)
    reactivity_seconds: 259200          # 3 days
    max_escalation_seconds: 1814400     # 21 days

    # Transparency: balanced within the collective
    transparency_level: balanced

    # Escalation: detailed but lenient
    escalation_granularity: detailed

    # Reviews: occasional (quarterly)
    review_frequency: quarterly

    # Notification scope: relevant project teams
    notification_scope: department

    # Patterns: low sensitivity
    pattern_sensitivity: low
    pattern_window_days: 90             # 3 months
    pattern_min_events: 5

    # Severity: high threshold (only severe issues escalate quickly)
    severity_threshold: high
    severity_policy:
      critical:
        immediate_escalation: true
      major:
        immediate_escalation: false
      minor:
        immediate_escalation: false

    # Logging: minimal, short retention
    logging_level: minimal
    log_retention_days: 180             # ~6 months

    # Automation: low (mostly human‑driven)
    automation_level: low

    # Defaults
    default_task_metadata:
      visibility: internal
      default_priority: low
      default_reactivity_seconds: 259200

    # Cyclic Overview
    cyclic_overview:
      enabled: true
      schedule:
        weekly: false
        monthly: false
        yearly: true
      threshold_triggers:
        incident_frequency:
          min_events: 5
          window_days: 90
        cross_departmental_trends: false
        high_risk_indicators: false

===== END 7-orgo-organization-profiles-and-cyclic-overview.md (#0007) =====

===== BEGIN 8-orgo-cyclic-overview-labels-and-flow-rules.md (#0008) =====
﻿<!-- INDEX: Doc 8 – Cyclic Overview, Labels & Universal Flow Rules (Orgo v3) -->
Index

8.1 Purpose & scope

8.2 Core concepts & glossary
– Organization (tenant)
– User vs Person
– Case
– Task
– Label
– Profile
– Insights / Cyclic overview

8.3 Labeling system (vertical & horizontal axes)
8.3.1 Label structure (canonical format)
8.3.2 Vertical axis – levels & broadcast bases
8.3.3 Categories (first decimal)
8.3.4 Subcategories (second decimal)
8.3.5 Horizontal roles (functional axis)
8.3.6 Broadcast bases (10/100/1000) – informational by default

8.4 Canonical JSON contracts (Case & Task)
8.4.1 Case JSON schema
8.4.2 Task JSON schema

8.5 Status lifecycles & allowed transitions
8.5.1 Case status lifecycle (CASE_STATUS)
8.5.2 Task status lifecycle (TASK_STATUS)

8.6 Cyclic overview system (pattern recognition)
8.6.1 Review frequencies (weekly / monthly / yearly)
8.6.2 Case lifecycle in the cyclic system
8.6.3 Threshold triggers (incident frequency, cross‑department trends, high‑risk indicators)
8.6.4 Example: wet floor pattern

8.7 Universal rules for information flow
8.7.1 Flow types (vertical, horizontal, cyclic)
8.7.2 Rule 1 – Function‑based routing
8.7.3 Rule 2 – Time‑based escalation (reactivity_time, reactivity_deadline_at)
8.7.4 Rule 3 – Broadcast semantics
8.7.5 Rule 4 – Role‑driven collaboration
8.7.6 Rule 5 – Categorization‑based handling

8.8 Implementation & cross‑document rules
8.8.1 JSON vs DB naming
8.8.2 State enforcement
8.8.3 Broadcast handling
8.8.4 Cyclic reviews as work

8.9 Scope cleanup – replacement of “Site Navigation Map”


---

# Doc 8 – Cyclic Overview, Labels & Universal Flow Rules (Orgo v3)

**Document ID**: `orgo-v3-doc-8`
**Role in set**: 8/8 (Labels, Case/Task JSON, Cyclic Overview, Flow Rules)
**Version**: `3.0.0`

**Depends on and must align with**:

* **Doc 1 – Database Schema Reference (Custom Tables)** – `cases`, `tasks`, label fields, and analytics tables. 
* **Doc 2 – Foundations, Locked Variables & Operational Checklists** – canonical enums (`TASK_STATUS`, `CASE_STATUS`, `TASK_PRIORITY`, `TASK_SEVERITY`, `VISIBILITY`), canonical Task field set. 
* **Doc 3 – Domain Modules (Orgo v3)** – domain adapters over the central Task/Case engine. 
* **Doc 5 – Core Services Specification** – task handler, workflow engine, state machine, email gateway. 
* **Doc 6 – Insights Module Config Parameters** – analytics retention, pattern windows, DAGs, reporting cache. 
* **Doc 7 – Organization Profiles & Cyclic Overview Settings** – reactivity, transparency, pattern sensitivity, cyclic review schedules. 

> **Normative note**
>
> * **Doc 2** is the source of truth for enums and the canonical Task field set; **Doc 1** is canonical for physical schemas.
> * This document is canonical for:
>
>   * Labeling system semantics (vertical & horizontal axes).
>   * Case and Task JSON contracts at the boundary (aligned to Doc 1/2).
>   * Status lifecycles and allowed transitions.
>   * Cyclic review / pattern‑recognition semantics and flow rules.
> * If you find conflicts, Doc 1/2 win for schemas/enums; this doc must be updated.

---

## 8.1 Purpose & Scope

This document defines:

1. How Orgo **labels and routes** information across vertical (hierarchy/broadcast) and horizontal (functional) axes.
2. The **canonical JSON contracts** for Case and Task at API / message boundaries (consistent with DB and enums).
3. The **status lifecycles and allowed transitions** for Cases and Tasks (consumed by Core Services and domain modules).
4. The **cyclic overview system** that turns repeated incidents into audit/review Cases instead of just charts.

It assumes the multi‑tenant backbone, Task/Case model, domain modules, profiles, Insights star schema, and guardrails defined in Docs 1–7.

---

## 8.2 Core Concepts & Glossary

* **Organization (tenant)**
  Logical owner of data (`organization_id`), profiles, workflows, and configuration.

* **User vs Person**
  *User* = has an Orgo login (`user_accounts`).
  *Person* = who things are about (`person_profiles` – students, players, employees, community members).

* **Case**
  Long‑lived container for an incident, situation, pattern, or theme. It aggregates Tasks, labels, severity, participants, and context (location, groups, persons). Cases are what the cyclic overview reviews over time.

* **Task**
  The central unit of work. Tasks are created from signals (email/API/offline), live in a canonical global table, and have a strict, shared schema: type, category, subtype, label, status, priority, severity, visibility, **normalized ownership (`owner_role_id` / `owner_user_id`) plus denormalised `assignee_role`**, deadlines (`due_at`, `reactivity_time`, `reactivity_deadline_at`), escalation level, and metadata.

* **Label**
  A structured “information label” encoding *where* in the organization and *what kind of information* something is:

  ```text
  <BASE>.<CATEGORY><SUBCATEGORY>.<HORIZONTAL_ROLE?>
  ```

  Example: `100.94.Operations.Safety`

  * `100` – broadcast level (department heads / vertical tier).
  * `.9` – Crisis & emergency info.
  * `.4` – Report (structured reporting).
  * `Operations.Safety` – horizontal role.

* **Profile**
  A template (“friend_group”, “hospital”, “advocacy_group”, “retail_chain”, etc.) describing how intense/urgent/private things are: reactivity seconds, transparency level, review cadence, notification scope, pattern sensitivity, severity policy, logging depth, automation level. Profiles plug into task creation, escalation logic, cyclic reviews, logging, and privacy. 

* **Insights / Cyclic overview**
  An analytics module on top of star‑schema tables (`insights.dim_*`, `insights.fact_*`) plus Airflow DAGs. It continuously computes patterns and cyclic reviews and turns threshold crossings into new Cases.

---

## 8.3 Labeling System (Vertical & Horizontal Axes)

### 8.3.1 Label Structure (Canonical)

Canonical label format:

```text
<BASE>.<CATEGORY><SUBCATEGORY>.<HORIZONTAL_ROLE?>
```

* `<BASE>` – integer vertical base (level / broadcast scope).
* `<CATEGORY>` – first decimal: information category (1–9).
* `<SUBCATEGORY>` – second decimal: intent (1–5).
* `<HORIZONTAL_ROLE>` – optional functional role (e.g. `Ops.Maintenance`, `HR.Recruitment`).

Examples:

* `1.32` – CEO‑level compliance update.
* `11.51.HR.Recruitment` – department‑head level training request for HR Recruitment.
* `100.94.Operations.Safety` – department‑head broadcast of a crisis‑related safety report.

Tasks and Cases each have exactly one **canonical label** string (`tasks.label`, `cases.label`) in this format; additional classification is done via `label_definitions` / `entity_labels`. 

### 8.3.2 Vertical Axis – Levels & Broadcast Bases

Examples of vertical bases:

* **Individual / level‑scoped**

  * `1` – CEO.
  * `2` – C‑level leadership.
  * `11` – department head.
  * `101` – team lead.
  * `1001` – individual staff member.

* **Reserved broadcast bases**

  * `10` – broadcast for top management.
  * `100` – broadcast for department heads.
  * `1000` – broadcast for operational staff.

The base defines **who is in scope**, not what the information is.

### 8.3.3 Categories (First Decimal)

Categories (1–9) define the type of information:

1. Operational information
2. Strategic information
3. Compliance & reporting
4. Customer / client information
5. Training & development
6. Communication & coordination
7. Financial information
8. Technical & infrastructure information
9. Crisis & emergency information

Example: `100.94.Operations.Safety` → category `9` (“Crisis & Emergency”), subcategory `4` (“Report”).

### 8.3.4 Subcategories (Second Decimal)

Subcategories (1–5) define intent:

1. Requests – asking for resources, action, approval.
2. Updates – informing about progress or changes.
3. Decisions – approvals, rejections, policy changes.
4. Reports – structured reporting (audit, incident, performance).
5. Distribution – broadcast/distribution only.

### 8.3.5 Horizontal Roles (Functional Axis)

Horizontal roles are dot‑separated domain labels:

* IT: `IT.Support`, `IT.Network`, `IT.Security`, `IT.Development`
* HR: `HR.Recruitment`, `HR.Payroll`, `HR.Policy`, `HR.Training`
* Finance: `Finance.Audit`, `Finance.Reporting`, `Finance.Budgeting`
* Operations: `Ops.Maintenance`, `Ops.Logistics`, `Ops.Procurement`, `Ops.Scheduling`
* Customer: `Customer.Support`, `Customer.Feedback`

These are **descriptive** and extensible; they do not change the base routing semantics.

### 8.3.6 Broadcast Bases (10/100/1000) – Informational by Default

Labels whose base is `10`, `100`, or `1000` are **broadcasts**:

* `10.x` – executive broadcast.
* `100.x` – department head broadcast.
* `1000.x` – staff‑wide broadcast.

**Default rule**:

* Broadcast labels are **informational by default**: they do not automatically spawn mandatory Tasks.
* Tasks from broadcast labels are created **only** when a workflow rule explicitly says so (e.g. `auto_create_tasks: true` for a specific pattern).

Core services and domain modules must treat broadcasts as “distribute information” unless configuration overrides this.

---

## 8.4 Canonical JSON Contracts (Case & Task)

This section defines the JSON shape used at API boundaries. It must map cleanly to:

* Table `cases` and `tasks` in Doc 1. 
* Enums and canonical Task field set in Doc 2. 

### 8.4.1 Case JSON Schema

Operationally, Cases are stored in `cases` with the columns defined in Doc 1; this is their JSON contract.

```yaml
Case:
  type: object
  required:
    - case_id
    - organization_id
    - source_type
    - label
    - title
    - description
    - status
    - severity
  properties:
    case_id:
      type: string
      format: uuid
      description: Stable external identifier (maps from cases.id).
    organization_id:
      type: string
      format: uuid
    source_type:
      type: string
      enum: [email, api, manual, sync]
      description: Origin channel (maps to task_source_enum / cases.source_type).
    source_reference:
      type: string
      nullable: true
      description: Channel-specific reference (e.g. email message-id, external URI).
    label:
      type: string
      description: Canonical information label "<BASE>.<CATEGORY><SUBCATEGORY>.<HORIZONTAL_ROLE>".
    title:
      type: string
      maxLength: 512
    description:
      type: string
    status:
      type: string
      enum: [open, in_progress, resolved, archived]
      description: Case lifecycle; see §8.5.1 for transitions.
    severity:
      type: string
      enum: [minor, moderate, major, critical]
      description: JSON uses lower-case TASK_SEVERITY tokens; implementations MAY also accept upper-case forms and normalise to the canonical DB enum values (MINOR, MODERATE, MAJOR, CRITICAL).
    reactivity_time:
      type: string
      nullable: true
      description: ISO‑8601 duration (e.g. "PT2H"); DB uses interval.
    origin_vertical_level:
      type: integer
      nullable: true
      description: Base part of original label (e.g. 100, 1001).
    origin_role:
      type: string
      nullable: true
      description: Horizontal role of origin (e.g. "Ops.Maintenance").
    tags:
      type: array
      items:
        type: string
      nullable: true
    location:
      type: object
      additionalProperties: true
      nullable: true
      description: Structured location (site, building, GPS, etc.).
    metadata:
      type: object
      additionalProperties: true
      description: Case-level metadata (pattern_sensitivity, review settings, etc.).
    created_at:
      type: string
      format: date-time
      readOnly: true
    updated_at:
      type: string
      format: date-time
      readOnly: true
```

* `severity` piggybacks on `task_severity_enum` (`MINOR`/`MODERATE`/`MAJOR`/`CRITICAL`) at DB level; JSON uses the lower‑case forms.

### 8.4.2 Task JSON Schema

Task JSON reuses the canonical Task fields from Doc 2 and adds source/actor fields from Doc 1.


```yaml
Task:
  type: object
  required:
    - task_id
    - organization_id
    - type
    - category
    - label
    - status
    - priority
    - severity
    - visibility
  properties:
    task_id:
      type: string
      format: uuid
      description: Stable external identifier (maps from tasks.id).
    organization_id:
      type: string
      format: uuid
    case_id:
      type: string
      format: uuid
      nullable: true
      description: Case this task belongs to (if any).
    source:
      type: string
      enum: [email, api, manual, sync]
      description: Origin channel (task_source_enum).
    type:
      type: string
      description: Domain-level type, e.g. "maintenance", "hr_case", "education_support".
    category:
      type: string
      enum: [request, incident, update, report, distribution]
      description: Global category enum.
    subtype:
      type: string
      nullable: true
      description: Domain-specific subtype (often mirrored into metadata).
    label:
      type: string
      description: Canonical information label.
    title:
      type: string
      maxLength: 512
    description:
      type: string
    status:
      type: string
      enum: [PENDING, IN_PROGRESS, ON_HOLD, COMPLETED, FAILED, ESCALATED, CANCELLED]
      description: TASK_STATUS; JSON MAY also use lower-case forms that map 1:1.
    priority:
      type: string
      enum: [LOW, MEDIUM, HIGH, CRITICAL]
    severity:
      type: string
      enum: [MINOR, MODERATE, MAJOR, CRITICAL]
    visibility:
      type: string
      enum: [PUBLIC, INTERNAL, RESTRICTED, ANONYMISED]
      description: VISIBILITY enum; governs access and export semantics.
    assignee_role:
      type: string
      nullable: true
      description: Denormalised routing role label (e.g. "Ops.Maintenance"); current primary assignee for UX, not the full history.
    created_by_user_id:
      type: string
      format: uuid
      nullable: true
      description: User that created the task (system actor).
    requester_person_id:
      type: string
      format: uuid
      nullable: true
      description: Person the work is for (student, player, employee, etc.).
    owner_role_id:
      type: string
      format: uuid
      nullable: true
      description: Primary owning role for this task (FK → roles.id).
    owner_user_id:
      type: string
      format: uuid
      nullable: true
      description: Direct owner (FK → user_accounts.id); may be null if owned only by a role.
    due_at:
      type: string
      format: date-time
      nullable: true
    reactivity_time:
      type: string
      nullable: true
      description: ISO‑8601 duration (e.g. "PT2H"); SLA window from creation used to derive reactivity_deadline_at.
    reactivity_deadline_at:
      type: string
      format: date-time
      nullable: true
      readOnly: true
      description: Computed deadline for first response (usually created_at + reactivity_time under the active profile).
    escalation_level:
      type: integer
      description: 0 = none; 1+ = depth in escalation path.
    closed_at:
      type: string
      format: date-time
      nullable: true
      readOnly: true
      description: Timestamp when the task entered a terminal state (COMPLETED, FAILED or CANCELLED).
    metadata:
      type: object
      additionalProperties: true
      description: Domain-specific fields; must not duplicate core fields.
    created_at:
      type: string
      format: date-time
      readOnly: true
    updated_at:
      type: string
      format: date-time
      readOnly: true
```

* Core services must reject unknown enum values and treat `status`, `priority`, `severity`, and `visibility` as the canonical enums from Doc 2.
* Note: multiple assignees and assignment history are stored in `task_assignments`; `assignee_role` is a denormalised convenience field for routing and UI.
**Note:** Task comments use the COMMENT_VISIBILITY enum (`internal_only`, `requester_visible`, `org_wide`) defined in Doc 2 §2.6.1. Implementations MUST enforce the same visibility values and semantics when exposing `task_comments` through API or domain views.


---

## 8.5 Status Lifecycles & Allowed Transitions

Any service that mutates `cases.status` or `tasks.status` must enforce these state machines. Invalid transitions must be rejected and logged as validation errors (`INVALID_TASK_STATE_TRANSITION`, similar for Cases).

### 8.5.1 Case Status Lifecycle

**CASE_STATUS** (from Doc 2): `open`, `in_progress`, `resolved`, `archived`.

Semantics:

* `open` – newly created, not yet actively being worked.
* `in_progress` – actively being handled; typically has open Tasks.
* `resolved` – underlying issue addressed; still available for reviews and follow‑ups.
* `archived` – fully closed; retained only for history/compliance.

**Allowed transitions:**

* `open` → `in_progress`
* `open` → `resolved` (immediate resolution)
* `open` → `archived` (triaged as out‑of‑scope / duplicate / spam with reason in metadata)
* `in_progress` → `resolved`
* `in_progress` → `archived` (dropped/invalidated with reason)
* `resolved` → `archived`
* `resolved` → `in_progress` (re‑opened due to recurrence or new information)

`archived` is terminal in normal flows; reopening an archived Case should be treated as an exceptional governance action and recorded in audit logs.

**Unresolved Cases (for cyclic overview)**

A Case is considered **unresolved** if its status is `open` or `in_progress`. Cyclic overview jobs focus thresholds on unresolved Cases plus recently resolved ones.

### 8.5.2 Task Status Lifecycle

Canonical `TASK_STATUS` (Doc 2/Doc 5):

```text
PENDING
IN_PROGRESS
ON_HOLD
COMPLETED
FAILED
ESCALATED
CANCELLED
```

Semantics:

* `PENDING` – created, not started.
* `IN_PROGRESS` – actively being worked.
* `ON_HOLD` – paused, waiting on dependency/decision.
* `COMPLETED` – done successfully.
* `FAILED` – attempted but unsuccessful; further work may require new Task/Case.
* `ESCALATED` – escalated to higher authority or different queue.
* `CANCELLED` – explicitly stopped; no further work.

**Allowed transitions** (locked to Core Services state machine):

* `PENDING` → `IN_PROGRESS`
* `PENDING` → `CANCELLED`
* `IN_PROGRESS` → `ON_HOLD`
* `IN_PROGRESS` → `COMPLETED`
* `IN_PROGRESS` → `FAILED`
* `IN_PROGRESS` → `ESCALATED`
* `ON_HOLD` → `IN_PROGRESS`
* `ON_HOLD` → `CANCELLED`
* `ESCALATED` → `IN_PROGRESS`
* `ESCALATED` → `COMPLETED`
* `ESCALATED` → `FAILED`
* `COMPLETED`, `FAILED`, `CANCELLED` – terminal (no further transitions).

**Normative note (closed_at):**
When a task enters a terminal state (`COMPLETED`, `FAILED`, or `CANCELLED`), Core Services **MUST** set `closed_at` to the transition timestamp. When a task is in a non‑terminal state (`PENDING`, `IN_PROGRESS`, `ON_HOLD`, `ESCALATED`), `closed_at` MUST remain `null`.

**Unresolved Tasks (for escalation & patterns)**

For escalation logic and cyclic overview, a Task is **unresolved** if status ∈ {`PENDING`, `IN_PROGRESS`, `ON_HOLD`, `ESCALATED`}. Only Tasks in unresolved states contribute to “overdue” calculations; all states contribute to patterns.

---

## 8.6 Cyclic Overview System (Pattern Recognition)

The cyclic overview system ensures that individual Cases/Tasks feed into **weekly, monthly, and yearly review loops**, driving new audit/review Cases when thresholds are crossed.

Pattern windows and thresholds are parameterized via:

* Insights config (`insights.patterns.*`) – technical window lengths and thresholds. 
* Organization profiles (`profiles.*.cyclic_overview.*`) – behavioural knobs per archetype (friend_group, hospital, advocacy_group, etc.). 

### 8.6.1 Review Frequencies

By default (subject to org profile and Insights config):

* **Weekly review**

  * Focus: critical/unresolved Cases and short‑window patterns.
  * Scope: all `CRITICAL` severity Cases plus unresolved Cases and high‑sensitivity domains (e.g., hospitals, HR).

* **Monthly review**

  * Focus: trends by department, label base, category, and location.
  * Scope: Cases from the last 1–6 months depending on `pattern_window_days` (profile + insights).

* **Yearly review**

  * Focus: systemic issues and long‑term risk.
  * Scope: Cases in the last 12–24 months (configurable; must fit within analytics retention).

Exact windows (e.g. 28 days / 180 days / 730 days) are defined in Doc 6 and profile templates in Doc 7; this document defines their semantics.

### 8.6.2 Case Lifecycle in the Cyclic System

1. **Signal → Case/Task**

   * Email/API/offline imports create Tasks in the central engine; some Tasks create or attach to Cases via workflow rules.
   * Each Case receives:

     * `label` (e.g. `100.94.Operations.Safety`).
     * `severity` (`MINOR`–`CRITICAL`).
     * `reactivity_time` derived from the org profile, task/category, and severity.

2. **Immediate handling**

   * Local Tasks are created and worked through the Task state machine.
   * Case status is `open` or `in_progress` until the underlying situation is addressed.

3. **Resolution**

   * Once core work is done:

     * Tasks end in `COMPLETED` / `FAILED` / `CANCELLED`.
     * Case moves to `resolved` (still reviewable) or `archived` (for triaged/rejected items).

4. **Weekly roll‑up**

   * Weekly DAG (`insights_weekly_pattern_review`) reads operational `tasks` and `cases` into `insights.fact_*` tables.
   * It flags:

     * Overdue unresolved Cases (past their reactivity window / deadline).
     * Short‑window clusters (e.g. 2–3 similar high‑severity incidents in 7 days for a hospital profile).

5. **Monthly roll‑up**

   * Monthly DAG aggregates patterns by label base, category, location, and domain.
   * When thresholds are crossed (see 8.6.3), it creates **audit Cases** (e.g. `11.94.Operations.Safety.Audit`) via Core Services.

6. **Yearly roll‑up**

   * Yearly DAG computes systemic patterns (e.g. repeated “near misses” or chronic workload hotspots).
   * It opens **review Cases** for leadership (e.g. `2.94.Leadership.Safety.Review`), which themselves have Tasks.

### 8.6.3 Threshold Triggers (Semantic Rules)

Thresholds are configured (per environment & profile) via Doc 6/7; this section defines their meaning.

Typical triggers:

* **Incident frequency**

  * Example: “≥ N similar incidents in window_days” (e.g. 5 wet‑floor incidents in 180 days in the same lobby) → open an audit Case.

* **Cross‑department trends**

  * Same label category across multiple vertical bases (e.g. repeated safety incidents in different departments) → leadership review Case.

* **High‑risk indicators**

  * Specific tags/labels (e.g. self‑harm risk, serious harassment) with low `pattern_min_events` thresholds → rapid pattern Cases.

**Normative rule**:
When a threshold fires, the system **must** create a Case (usually audit/review) and optionally Tasks; it is not sufficient to just mark a dashboard. This keeps patterns in the same operational loop as regular work.

### 8.6.4 Example: Wet Floor Pattern

* **Week 1** – 3 Tasks: `PENDING/IN_PROGRESS` for wet floor in lobby; one Case `open`.
* **Month end** – 5 Cases labeled `100.94.Operations.Safety` about wet floors in same location → crosses configured `incident_frequency` threshold.

Result:

* New Case: `11.94.Operations.Safety.Audit` created by Insights/cyclic job.
* Tasks: inspection, root‑cause analysis, signage policy review.

---

## 8.7 Universal Rules for Information Flow

These rules apply regardless of domain (maintenance, HR, education, NGOs, etc.). Domain modules plug into this by mapping their own metadata and subtypes onto the shared label and Task/Case system.

### 8.7.1 Flow Types

* **Vertical**

  * Upward: incident reports, escalations, approvals.
  * Downward: policies, decisions, directives.

* **Horizontal**

  * Within a function (e.g. Ops team) or between functions (e.g. HR ↔ IT).

* **Cyclic**

  * Periodic loops (weekly/monthly/yearly) that take aggregated patterns and push them back into Cases/Tasks.

### 8.7.2 Rule 1 – Function‑Based Routing

Routing is based on **role/responsibility**, not individuals:

* Label base + category + horizontal role → which role queue initially owns a Case/Task.
* Domain modules may add further hints (subtype, domain metadata), but cannot bypass canonical label semantics.

Example:

* Harassment report → Case labeled `100.94.HR.CaseOfficer`, Task(s) assigned by routing rules to HR case officer roles.

### 8.7.3 Rule 2 – Time‑Based Escalation

Every Task and Case gets a **reactivity_time** derived from:

* Organization profile (friend_group vs hospital vs military). 
* Task category, severity, domain, and sometimes label.

Core services derive `reactivity_deadline_at` from `created_at + reactivity_time` (or the profile/workflow‑specific rule) and use this as the canonical timestamp for escalation checks. Escalation jobs **MUST** compare the current time against `reactivity_deadline_at`, not recompute ad‑hoc from raw profile settings.

If unresolved when `reactivity_time` / `reactivity_deadline_at` elapses:

* Workflow/Task Handler must trigger escalation:

  * Increase `escalation_level`.
  * Move Task to `ESCALATED` or reassign to higher vertical base.
  * Notify appropriate roles/teams according to profile and notification config.

Example:

* Hospital profile: critical safety Task → `reactivity_seconds = 300` (5 minutes). If still `PENDING`/`IN_PROGRESS` after 5 minutes, escalate to on‑call clinical safety team.

### 8.7.4 Rule 3 – Broadcast Semantics

Broadcast bases (`10`, `100`, `1000`) are used for *awareness*:

* Downward flows: leadership → departments → staff.
* Sideways flows: cross‑department info distribution.

Default behaviour:

* Broadcast‑labeled items do **not** create Tasks.
* If a policy or safety pattern needs follow‑up, workflows explicitly create Tasks or Cases from those broadcasts.

### 8.7.5 Rule 4 – Role‑Driven Collaboration

Horizontal handoffs are expressed via labels and routing rules:

```text
11.51.HR.Recruitment   →   11.11.IT.Support
```

Domain modules for HR and IT plug into the same Task engine and label semantics; they do not own separate task tables or lifecycles.

### 8.7.6 Rule 5 – Categorization‑Based Handling

Subcategories (`.1`–`.5`) drive default handling patterns:

* `.1` **Requests** – flow upward or laterally for approval/action; typically spawn Tasks.
* `.2` **Updates** – flow horizontally/downward for awareness; usually do **not** create Tasks unless configured.
* `.3` **Decisions** – flow downward once approvals/rejections are made.
* `.4` **Reports** – flow upward into cyclic overview and analytics.
* `.5` **Distribution** – pure broadcasts; no Tasks unless explicitly configured.

Workflow rules in Doc 3/5 encode the actual behaviour per organization and domain.

---

## 8.8 Implementation & Cross‑Document Rules

### 8.8.1 JSON vs DB Naming

* DB primary keys: typically `id`; API/JSON must expose them as `task_id` / `case_id`.
* DB enums: stored as canonical uppercase (`PENDING`, `ANONYMISED`); JSON may use either uppercase or lower‑case; mapping is 1:1 and enforced on input.

### 8.8.2 State Enforcement

* Task Handler (`task_handler`) and domain handlers must enforce the Task state machine in §8.5.2 / Doc 5 and reject invalid transitions.
* Any service that updates `cases.status` must enforce §8.5.1 and log state changes in `activity_logs` / `task_events`.

### 8.8.3 Broadcast Handling

* Domain modules must treat broadcast labels as non‑actionable unless a rule explicitly sets `auto_create_tasks: true` (or equivalent) for that pattern.
* Reasons for exceptions (e.g. mandated safety drills) should be documented in domain configs.

### 8.8.4 Cyclic Reviews as Work

* Cyclic overview jobs must create **real Cases and Tasks** (e.g. audits, systemic reviews) for patterns, not merely dashboards.
* These Cases use labels such as:

  * `11.94.Operations.Safety.Audit` – departmental safety audit.
  * `2.94.Leadership.Safety.Review` – leadership‑level safety review.

These Cases then follow the same Case/Task lifecycles and visibility rules as any other work.

---

## 8.9 Scope Cleanup – Replacement of “Site Navigation Map”

Earlier drafts used “site navigation map” as the title and mixed UI navigation content into this document.

For Orgo v3:

* **Doc 8 is purely back‑end/process level**:

  * Labeling semantics.
  * Case/Task JSON contracts.
  * Status lifecycles and transitions.
  * Cyclic overview and pattern semantics.

* Any UI or navigation diagrams must live in separate Interface/UX documentation and reference this document only for data and flow semantics.

This version supersedes all previous “Doc 8” drafts and is the integral, updated specification for labels, JSON contracts, and cyclic overview in Orgo v3.

===== END 8-orgo-cyclic-overview-labels-and-flow-rules.md (#0008) =====
